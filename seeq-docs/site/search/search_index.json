{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ITV Asset Tree \u2013 Module Reference","text":"<p>This module defines the FastAPI application for the ITV Asset Tree API.</p> <p>It includes startup logic, middleware for logging requests, and dynamically loads all route modules from the <code>api/routes</code> directory.</p> <p>Module providing functions and request models for uploading CSVs, detecting and resolving duplicates, generating lookup strings, setting parent paths, and pushing lookup tables into Seeq.</p> <p>Handles application startup tasks such as connecting to Seeq and ensuring user configuration files are available.</p> <p>Defines application configuration settings using Pydantic BaseSettings.</p> <p>Loads environment variables from a <code>.env</code> file and exposes configuration attributes such as server credentials, debug mode, and host address.</p> <p>Provides the TreeBuilder class for managing asset tree creation and manipulation in Seeq.</p> <p>Supports building empty or structured trees, visualizing their structure, and retrieving a push manager for deployment into Seeq.</p> <p>Provides the TreeLoader class for reloading asset trees from Seeq.</p> <p>This module ensures that tree objects are updated with the latest state from the server by re-fetching the structure using Seeq SPy.</p> <p>Provides a factory class for instantiating TreeModifier objects with configurable push strategies.</p> <p>This allows clients to dynamically construct tree modification workflows based on immediate, batch, dry-run, or search-only modes.</p> <p>Provides the TreePropertyManager class for applying metadata-based property updates to Seeq asset trees.</p> <p>This class modifies existing asset items based on structured metadata and commits changes to the tree.</p> <p>Provides the TreeVisualizer class for rendering Seeq asset trees as formatted string output.</p> <p>The visualizer caches the last fetched tree to avoid redundant API calls and supports both in-memory visualization and live tree retrieval using a TreeModifier.</p> <p>Defines Pydantic models for CSV lookup request and response schemas.</p> <p>Used in API endpoints for uploading and processing CSV files into structured dictionaries.</p> <p>Defines request schema models related to asset tree operations.</p> <p>Includes models for creating, modifying, and interacting with asset trees in Seeq.</p> <p>Utility functions for cleaning signal metadata and extracting component labels for tree building.</p> <p>Includes: - <code>extract_component_column</code>: Adds a 'Component' column based on regex patterns from config. - <code>clean_signal_leaf_name</code>: Simplifies signal names to avoid recursive asset tree nesting.</p> <p>Provides the CSVHandler class for loading and validating CSV files used in the asset tree system.</p> <p>This module logs file information and raises clear exceptions for file-related errors.</p> <p>Defines a set of strategies for resolving duplicates in tabular datasets.</p> <p>Includes base and concrete classes for different resolution approaches, including keeping the first or last duplicate, removing all, or applying a custom user-defined rule.</p> <p>Configures and initializes logging for the ITV Asset Tree application.</p> <p>Provides helper functions for logging at various levels (info, warning, error, debug), and sets up both console and file logging using a unified format.</p>"},{"location":"#itv_asset_tree.api.api.InsertItemRequest","title":"<code>InsertItemRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for inserting an item into an asset tree.</p> <p>Attributes:</p> Name Type Description <code>tree_name</code> <code>str</code> <p>The name of the asset tree.</p> <code>workbook_name</code> <code>str</code> <p>The name of the workbook containing the tree.</p> <code>parent_name</code> <code>str</code> <p>The name of the parent node.</p> <code>item_definition</code> <code>ItemDefinition</code> <p>Definition of the item to be inserted.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>class InsertItemRequest(BaseModel):\n    \"\"\"\n    Request model for inserting an item into an asset tree.\n\n    Attributes:\n        tree_name (str): The name of the asset tree.\n        workbook_name (str): The name of the workbook containing the tree.\n        parent_name (str): The name of the parent node.\n        item_definition (ItemDefinition): Definition of the item to be inserted.\n    \"\"\"\n    tree_name: str\n    workbook_name: str\n    parent_name: str\n    item_definition: ItemDefinition\n</code></pre>"},{"location":"#itv_asset_tree.api.api.ItemDefinition","title":"<code>ItemDefinition</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an item definition within an asset tree.</p> <p>Attributes:</p> Name Type Description <code>Name</code> <code>str</code> <p>The name of the item.</p> <code>Type</code> <code>Optional[str]</code> <p>The type of the item (e.g., Signal, Metric, Condition).</p> <code>Formula</code> <code>Optional[str]</code> <p>Formula associated with the item, if applicable.</p> <code>FormulaParams</code> <code>Optional[Dict]</code> <p>Parameters required for formula calculation.</p> <code>Properties</code> <code>Optional[Dict[str, str]]</code> <p>Additional properties associated with the item.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>class ItemDefinition(BaseModel):\n    \"\"\"\n    Represents an item definition within an asset tree.\n\n    Attributes:\n        Name (str): The name of the item.\n        Type (Optional[str]): The type of the item (e.g., Signal, Metric, Condition).\n        Formula (Optional[str]): Formula associated with the item, if applicable.\n        FormulaParams (Optional[Dict]): Parameters required for formula calculation.\n        Properties (Optional[Dict[str, str]]): Additional properties associated with the item.\n    \"\"\"\n    Name: str\n    Type: Optional[str] = None  # Type remains optional\n    Formula: Optional[str] = None\n    FormulaParams: Optional[Dict] = Field(default_factory=dict)\n    Properties: Optional[Dict[str, str]] = Field(default_factory=dict)\n</code></pre>"},{"location":"#itv_asset_tree.api.api.ModifyRequest","title":"<code>ModifyRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for modifying an asset tree.</p> <p>Attributes:</p> Name Type Description <code>tree_name</code> <code>str</code> <p>The name of the tree to modify.</p> <code>workbook_name</code> <code>str</code> <p>The name of the workbook containing the tree.</p> <code>operation</code> <code>str</code> <p>The modification operation (insert, move, remove).</p> <code>parent_name</code> <code>Optional[str]</code> <p>The parent node where the modification applies.</p> <code>item_definition</code> <code>Optional[Dict]</code> <p>The definition of the item being modified.</p> <code>source_path</code> <code>Optional[str]</code> <p>The source path for move operations.</p> <code>destination_path</code> <code>Optional[str]</code> <p>The destination path for move operations.</p> <code>item_path</code> <code>Optional[str]</code> <p>The path of the item being removed.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>class ModifyRequest(BaseModel):\n    \"\"\"\n    Request model for modifying an asset tree.\n\n    Attributes:\n        tree_name (str): The name of the tree to modify.\n        workbook_name (str): The name of the workbook containing the tree.\n        operation (str): The modification operation (insert, move, remove).\n        parent_name (Optional[str]): The parent node where the modification applies.\n        item_definition (Optional[Dict]): The definition of the item being modified.\n        source_path (Optional[str]): The source path for move operations.\n        destination_path (Optional[str]): The destination path for move operations.\n        item_path (Optional[str]): The path of the item being removed.\n    \"\"\"\n    tree_name: str\n    workbook_name: str\n    operation: str\n    parent_name: Optional[str] = None  \n    item_definition: Optional[Dict] = None\n    source_path: Optional[str] = None  \n    destination_path: Optional[str] = None \n    item_path: Optional[str] = None \n</code></pre>"},{"location":"#itv_asset_tree.api.api.MoveRequest","title":"<code>MoveRequest</code>","text":"<p>               Bases: <code>ModifyRequest</code></p> <p>Request model for moving an item within an asset tree.</p> <p>Attributes:</p> Name Type Description <code>source_path</code> <code>str</code> <p>The current path of the item being moved.</p> <code>destination_path</code> <code>str</code> <p>The target path where the item will be moved.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>class MoveRequest(ModifyRequest):\n    \"\"\"\n    Request model for moving an item within an asset tree.\n\n    Attributes:\n        source_path (str): The current path of the item being moved.\n        destination_path (str): The target path where the item will be moved.\n    \"\"\"\n    source_path: str\n    destination_path: str\n</code></pre>"},{"location":"#itv_asset_tree.api.api.RemoveRequest","title":"<code>RemoveRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for removing an item from an asset tree.</p> <p>Attributes:</p> Name Type Description <code>tree_name</code> <code>str</code> <p>The name of the tree containing the item.</p> <code>workbook_name</code> <code>str</code> <p>The name of the workbook containing the tree.</p> <code>item_path</code> <code>str</code> <p>The path of the item to be removed.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>class RemoveRequest(BaseModel):\n    \"\"\"\n    Request model for removing an item from an asset tree.\n\n    Attributes:\n        tree_name (str): The name of the tree containing the item.\n        workbook_name (str): The name of the workbook containing the tree.\n        item_path (str): The path of the item to be removed.\n    \"\"\"\n    tree_name: str\n    workbook_name: str\n    item_path: str  # Ensure full path is provided\n</code></pre>"},{"location":"#itv_asset_tree.api.api.archive_tree","title":"<code>archive_tree(request)</code>","text":"<p>Archives an asset tree in Seeq.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>ArchiveRequest</code> <p>Contains the tree name and workbook name.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A message indicating the success or failure of the archive operation.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>def archive_tree(request: ArchiveRequest):\n    \"\"\"\n    Archives an asset tree in Seeq.\n\n    Args:\n        request (ArchiveRequest): Contains the tree name and workbook name.\n\n    Returns:\n        dict: A message indicating the success or failure of the archive operation.\n    \"\"\"\n    try:\n        archiver = TreeArchiver(request.tree_name, request.workbook)\n        archiver.archive()\n        return {\"message\": f\"\u2705 Tree '{request.tree_name}' archived successfully.\"}\n    except Exception as e:\n        return {\n            \"status\": 500,\n            \"message\": f\"\u274c Archive operation failed: {str(e)}\"\n        }\n</code></pre>"},{"location":"#itv_asset_tree.api.api.create_empty_tree","title":"<code>create_empty_tree(request)</code>","text":"<p>Creates an empty asset tree and pushes it to Seeq.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>dict</code> <p>The request containing 'body' with tree_name and workbook_name.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A success message and a visualization of the tree.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>def create_empty_tree(request):\n    \"\"\"\n    Creates an empty asset tree and pushes it to Seeq.\n\n    Args:\n        request (dict): The request containing 'body' with tree_name and workbook_name.\n\n    Returns:\n        dict: A success message and a visualization of the tree.\n    \"\"\"\n\n    global current_tree, current_workbook_name, current_tree_name\n\n    try:\n        body = request.get(\"body\", {})\n        tree_name = body.get(\"tree_name\", \"\").strip()\n        workbook_name = body.get(\"workbook_name\", \"\").strip()\n\n        if not tree_name or not workbook_name:\n            return {\"detail\": \"\u26a0\ufe0f Tree name and workbook name are required.\"}\n\n        tree_builder = TreeBuilder(workbook=workbook_name)\n        current_tree = tree_builder.build_empty_tree(friendly_name=tree_name, description=\"Empty tree created\")\n\n        current_tree.push()\n\n        log_info(\"\ud83d\udcca [DEBUG] Tree push succeeded.\")\n\n        visualization = f\"{tree_name}\\n|-- (empty root node)\"\n        return {\"message\": f\"\u2705 Empty tree '{tree_name}' created and pushed successfully.\", \"tree_structure\": visualization}\n    except Exception as e:\n        return {\"detail\": f\"\u274c Failed to create and push empty tree: {e}\"}\n</code></pre>"},{"location":"#itv_asset_tree.api.api.insert_item","title":"<code>insert_item(request)</code>","text":"<p>Inserts an item into an asset tree.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>InsertItemRequest</code> <p>The request containing tree, workbook, and item details.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A message indicating successful insertion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If insertion fails.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>def insert_item(request: InsertItemRequest):\n    \"\"\"\n    Inserts an item into an asset tree.\n\n    Args:\n        request (InsertItemRequest): The request containing tree, workbook, and item details.\n\n    Returns:\n        dict: A message indicating successful insertion.\n\n    Raises:\n        HTTPException: If insertion fails.\n    \"\"\"\n    try:\n        modifier = TreeModifierFactory.create(request.workbook_name, request.tree_name, strategy=\"immediate\")\n        parent = request.parent_name\n        item_data = request.item_definition if isinstance(request.item_definition, dict) else request.item_definition.dict()\n\n        if not item_data[\"Name\"] or not item_data[\"Type\"]:\n            return {\n                \"status\": 400,\n                \"message\": \"\u274c Missing Name or Type.\"\n            }\n\n        modifier.insert_item(parent, item_data)\n\n        return {\"message\": f\"\u2705 Item '{item_data['Name']}' added under '{parent}'.\"}\n    except Exception as e:\n        return {\n            \"status\": 500,\n            \"message\": f\"\u274c Insert failed: {str(e)}\"\n        }\n</code></pre>"},{"location":"#itv_asset_tree.api.api.modify_tree","title":"<code>modify_tree(request)</code>","text":"<p>Modifies an asset tree by inserting, moving, removing, or archiving items.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>dict</code> <p>The request containing tree name, workbook name, and modification details.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A message indicating the success of the operation and updated tree structure.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>def modify_tree(request):\n    \"\"\"\n    Modifies an asset tree by inserting, moving, removing, or archiving items.\n\n    Args:\n        request (dict): The request containing tree name, workbook name, and modification details.\n\n    Returns:\n        dict: A message indicating the success of the operation and updated tree structure.\n    \"\"\"\n    try:\n        # Unpack dict request to Pydantic model if needed (for Data Lab frontend compatibility)\n        if isinstance(request, dict):\n            # Some callers wrap the payload inside a \"body\" key\n            body = request.get(\"body\", request)\n            request = ModifyRequest(**body)\n\n        log_debug(f\"\ud83d\udd04 [DEBUG] Received Modify Request: {request}\")\n\n        # Choose push strategy dynamically\n        push_strategy = \"immediate\" if request.operation in [\"insert\", \"move\", \"remove\"] else \"batch\"\n\n        modifier = TreeModifierFactory.create(\n            request.workbook_name, request.tree_name, strategy=push_strategy\n        )\n\n        if request.operation == \"insert\":\n            if request.item_definition is None:\n                return {\"message\": \"\u274c item_definition is missing.\", \"status\": 400}\n            item_data = request.item_definition if isinstance(request.item_definition, dict) else request.item_definition.dict()\n            modifier.insert_item(request.parent_name, item_data)\n\n        elif request.operation == \"move\":\n            if not request.source_path or not request.destination_path:\n                return {\"message\": \"\u274c Move request is missing source or destination path.\", \"status\": 400}\n            modifier.move_item(request.source_path, request.destination_path)\n\n        elif request.operation == \"remove\":\n            if not request.item_path:\n                return {\"message\": \"\u274c Remove request is missing item_path.\", \"status\": 400}\n            modifier.remove_item(request.item_path)\n\n        elif request.operation == \"archive\":\n            archiver = TreeArchiver(tree_name=request.tree_name, workbook=request.workbook_name)\n            archiver.archive()\n\n        return {\n            \"message\": f\"\u2705 Successfully performed '{request.operation}' operation on tree '{request.tree_name}'.\",\n            \"tree_structure\": modifier.visualize_tree()\n        }\n\n    except Exception as e:\n        log_error(f\"\u274c Modify operation failed: {str(e)}\")\n        return {\"message\": f\"\u274c Modify operation failed: {str(e)}\", \"status\": 500}\n</code></pre>"},{"location":"#itv_asset_tree.api.api.move_item","title":"<code>move_item(request)</code>","text":"<p>Moves an item within an asset tree.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>MoveRequest</code> <p>The request containing tree details and move paths.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A message indicating success.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If move fails.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>def move_item(request: MoveRequest):\n    \"\"\"\n    Moves an item within an asset tree.\n\n    Args:\n        request (MoveRequest): The request containing tree details and move paths.\n\n    Returns:\n        dict: A message indicating success.\n\n    Raises:\n        HTTPException: If move fails.\n    \"\"\"\n    try:\n        modifier = TreeModifierFactory.create(request.workbook_name, request.tree_name, strategy=\"immediate\")\n        modifier.move_item(request.source_path, request.destination_path)\n\n        return {\"message\": f\"\u2705 Moved item from '{request.source_path}' to '{request.destination_path}'.\"}\n    except Exception as e:\n        return {\n            \"status\": 400,\n            \"message\": f\"\u274c Move operation failed: {str(e)}\"\n        }\n</code></pre>"},{"location":"#itv_asset_tree.api.api.process_csv","title":"<code>process_csv(request)</code>","text":"<p>Processes an uploaded CSV file and builds an asset tree in Seeq.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>dict</code> <p>Should contain 'body' with 'tree_name' and 'workbook_name'.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Result with message and visualization.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>def process_csv(request):\n    \"\"\"\n    Processes an uploaded CSV file and builds an asset tree in Seeq.\n\n    Args:\n        request (dict): Should contain 'body' with 'tree_name' and 'workbook_name'.\n\n    Returns:\n        dict: Result with message and visualization.\n    \"\"\"\n\n    global current_tree, current_workbook_name, current_tree_name\n\n    body = request.get(\"body\", {})\n    tree_name = body.get(\"tree_name\")\n    workbook_name = body.get(\"workbook_name\")\n\n    if not tree_name or not workbook_name:\n        return {\"message\": \"\u26a0\ufe0f tree_name and workbook_name are required.\"}\n\n    if not spy.user:\n        log_info(\"\ud83d\udd0c Attempting Seeq login...\")\n        spy.login(url=HOST, username=USERNAME, password=PASSWORD)\n\n    try:\n        uploaded_files = os.listdir(UPLOAD_DIR)\n        if not uploaded_files:\n            raise FileNotFoundError(\"\u274c No CSV file found in the uploaded_files directory.\")\n\n        latest_file = max(uploaded_files, key=lambda f: os.path.getctime(os.path.join(UPLOAD_DIR, f)))\n        file_path = os.path.join(UPLOAD_DIR, latest_file)\n\n        data = pd.read_csv(file_path)\n        if \"Level 1\" not in data.columns:\n            raise ValueError(\"\u26a0\ufe0f CSV must contain a 'Level 1' column.\")\n\n        current_tree_name = tree_name\n        current_workbook_name = workbook_name\n\n        builder = TreeBuilder(workbook=current_workbook_name, csv_file=file_path)\n        builder.parse_csv()\n        builder.build_tree_from_csv(friendly_name=current_tree_name, description=\"\ud83c\udf33 Tree built from CSV\")\n\n        current_tree = builder.tree\n        builder.tree.push()\n\n        visualize_output = io.StringIO()\n        with redirect_stdout(visualize_output):\n            builder.tree.visualize()\n\n        return {\n            \"message\": f\"\u2705 CSV processed and tree '{current_tree_name}' pushed successfully.\",\n            \"columns\": list(builder.metadata.columns),\n            \"tree_structure\": visualize_output.getvalue().strip()\n        }\n\n    except Exception as e:\n        return {\"message\": f\"\u274c Failed to process and push CSV: {e}\"}\n</code></pre>"},{"location":"#itv_asset_tree.api.api.push_tree","title":"<code>push_tree(tree_name, workbook_name)</code>","text":"<p>Pushes an existing asset tree to Seeq.</p> <p>Parameters:</p> Name Type Description Default <code>tree_name</code> <code>str</code> <p>The name of the tree to push.</p> required <code>workbook_name</code> <code>str</code> <p>The workbook containing the tree.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A message indicating success.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If pushing fails.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>def push_tree(tree_name: str, workbook_name: str):\n    \"\"\"\n    Pushes an existing asset tree to Seeq.\n\n    Args:\n        tree_name (str): The name of the tree to push.\n        workbook_name (str): The workbook containing the tree.\n\n    Returns:\n        dict: A message indicating success.\n\n    Raises:\n        HTTPException: If pushing fails.\n    \"\"\"\n    try:\n        tree_modifier = TreeModifierFactory.create(workbook=workbook_name, tree_name=tree_name, strategy=\"immediate\")\n        tree_modifier.push_tree()\n\n        return {\"message\": f\"\u2705 Tree '{tree_name}' successfully pushed!\"}\n    except Exception as e:\n        return {\n            \"status\": 500,\n            \"message\": f\"\u274c Failed to push tree: {e}\"\n        }\n</code></pre>"},{"location":"#itv_asset_tree.api.api.remove_item","title":"<code>remove_item(request)</code>","text":"<p>Removes an item from an asset tree.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>RemoveRequest</code> <p>The request containing tree name, workbook, and item path.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A message indicating success.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If removal fails.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>def remove_item(request: RemoveRequest):\n    \"\"\"\n    Removes an item from an asset tree.\n\n    Args:\n        request (RemoveRequest): The request containing tree name, workbook, and item path.\n\n    Returns:\n        dict: A message indicating success.\n\n    Raises:\n        HTTPException: If removal fails.\n    \"\"\"\n    try:\n        log_debug(f\"\ud83d\udccc [DEBUG] Removing item at path: {request.item_path} in tree '{request.tree_name}'\")\n        modifier = TreeModifierFactory.create(request.workbook_name, request.tree_name, strategy=\"immediate\")\n\n        if not modifier.tree:\n            log_debug(f\"\u274c [DEBUG] Tree '{request.tree_name}' not found.\")\n            return {\n                \"status\": 404,\n                \"message\": f\"\u274c Tree '{request.tree_name}' not found.\"\n            }\n\n        modifier.remove_item(request.item_path)\n\n        log_debug(f\"\u2705 [DEBUG] Successfully removed: {request.item_path}\")\n\n        return {\"message\": f\"\u2705 Removed item '{request.item_path}' from the tree.\"}\n    except Exception as e:\n        log_error(f\"\u274c [ERROR] Remove operation failed: {e}\")\n        return {\n            \"status\": 400,\n            \"message\": f\"\u274c Remove operation failed: {str(e)}\"\n        }\n</code></pre>"},{"location":"#itv_asset_tree.api.api.search_tree","title":"<code>search_tree(tree_name, workbook_name)</code>","text":"<p>Searches for an existing asset tree in Seeq and retrieves its visualization.</p> <p>Parameters:</p> Name Type Description Default <code>tree_name</code> <code>str</code> <p>The name of the tree to search for.</p> required <code>workbook_name</code> <code>str</code> <p>The name of the workbook containing the tree.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Contains the tree structure visualization.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the tree is not found or visualization fails.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>def search_tree(tree_name: str, workbook_name: str):\n    \"\"\"\n    Searches for an existing asset tree in Seeq and retrieves its visualization.\n\n    Args:\n        tree_name (str): The name of the tree to search for.\n        workbook_name (str): The name of the workbook containing the tree.\n\n    Returns:\n        dict: Contains the tree structure visualization.\n\n    Raises:\n        HTTPException: If the tree is not found or visualization fails.\n    \"\"\"\n    try:\n        log_debug(f\"\ud83d\udd0d [DEBUG] Searching for tree '{tree_name}' in workbook '{workbook_name}'\")\n\n        # Ensure `strategy=None` to prevent push behavior\n        tree_modifier = TreeModifierFactory.create(workbook=workbook_name, tree_name=tree_name, strategy=None)\n\n        if not tree_modifier.tree:\n            return {\n                \"status\": 404,\n                \"message\": f\"\u274c Tree '{tree_name}' not found in workbook '{workbook_name}'.\"\n            }\n\n        # Fetch visualization and ensure it's valid\n        visualization = tree_modifier.visualize_tree()\n\n        if not visualization or visualization.strip() == \"\":\n            visualization = \"\u26a0\ufe0f No tree structure available.\"\n\n        return {\"tree_structure\": visualization}\n\n    except Exception as e:\n        log_error(f\"\u274c [ERROR] Failed to search and visualize tree: {e}\")\n        return {\n            \"status\": 500,\n            \"message\": f\"\u274c Failed to search and visualize tree: {e}\"\n        }\n</code></pre>"},{"location":"#itv_asset_tree.api.api.serve_frontend","title":"<code>serve_frontend()</code>","text":"<p>Serves the frontend <code>index.html</code> file.</p> <p>Returns:</p> Name Type Description <code>FileResponse</code> <p>The requested <code>index.html</code> file.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the file does not exist.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>def serve_frontend():\n    \"\"\"\n    Serves the frontend `index.html` file.\n\n    Returns:\n        FileResponse: The requested `index.html` file.\n\n    Raises:\n        HTTPException: If the file does not exist.\n    \"\"\"\n    index_html_path = os.path.join(frontend_dir, \"templates\", \"index.html\")\n\n    # Debugging output\n    log_debug(f\"\ud83d\udd0d [DEBUG] Expected path for index.html: {index_html_path}\")\n\n    if not os.path.exists(index_html_path):\n        log_error(f\"\u274c [ERROR] File not found at: {index_html_path}\")\n        return {\n            \"status\": 500,\n            \"message\": f\"\u274c File not found: {index_html_path}\"\n        }\n\n    log_debug(f\"\u2705 [DEBUG] index.html found, serving...\")\n    return FileResponse(index_html_path)\n</code></pre>"},{"location":"#itv_asset_tree.api.api.upload_csv","title":"<code>upload_csv(request)</code>","text":"<p>Uploads a CSV file and reads its columns.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>dict</code> <p>Contains the 'body' with the uploaded file.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Contains the filename and extracted columns.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>def upload_csv(request):\n    \"\"\"\n    Uploads a CSV file and reads its columns.\n\n    Args:\n        request (dict): Contains the 'body' with the uploaded file.\n\n    Returns:\n        dict: Contains the filename and extracted columns.\n    \"\"\"\n\n    file = request.get(\"body\", {}).get(\"file\")\n    if file is None:\n        return {\"detail\": \"\u26a0\ufe0f No file uploaded in request.\"}\n\n    file_location = os.path.join(\"/tmp\", file.filename)\n\n    try:\n        with open(file_location, \"wb\") as f:\n            f.write(file.file.read())  # file.file is a SpooledTemporaryFile\n\n        data = pd.read_csv(file_location)\n        return {\"filename\": file.filename, \"columns\": list(data.columns)}\n    except Exception as e:\n        return {\"detail\": f\"\u274c Failed to upload file: {str(e)}\"}\n</code></pre>"},{"location":"#itv_asset_tree.api.api.visualize_tree","title":"<code>visualize_tree(tree_name, workbook_name)</code>","text":"<p>Fetches the latest visualization of an asset tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree_name</code> <code>str</code> <p>The name of the tree to visualize.</p> required <code>workbook_name</code> <code>str</code> <p>The workbook containing the tree.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The tree structure visualization.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the tree is not found or visualization fails.</p> Source code in <code>itv_asset_tree/api/api.py</code> <pre><code>def visualize_tree(tree_name: str, workbook_name: str):\n    \"\"\"\n    Fetches the latest visualization of an asset tree.\n\n    Args:\n        tree_name (str): The name of the tree to visualize.\n        workbook_name (str): The workbook containing the tree.\n\n    Returns:\n        dict: The tree structure visualization.\n\n    Raises:\n        HTTPException: If the tree is not found or visualization fails.\n    \"\"\"\n    try:\n        log_debug(f\"\ud83d\udd0d [DEBUG] Received visualization request for Tree: {tree_name}, Workbook: {workbook_name}\")\n\n        # Fix: Use `strategy=None` instead of `operation`\n        tree_modifier = TreeModifierFactory.create(workbook=workbook_name, tree_name=tree_name, strategy=None)\n\n        if not tree_modifier.tree:\n            return {\n                \"status\": 404,\n                \"message\": f\"\u274c Tree '{tree_name}' not found in workbook '{workbook_name}'.\"\n            }\n\n        # Visualize the tree structure\n        visualization = tree_modifier.visualize_tree()\n\n        return {\"tree_structure\": visualization}\n\n    except Exception as e:\n        return {\n            \"status\": 500,\n            \"message\": f\"\u274c Failed to visualize tree: {e}\"\n        }\n</code></pre>"},{"location":"#itv_asset_tree.api.app.log_requests","title":"<code>log_requests(request, call_next)</code>  <code>async</code>","text":"<p>Middleware to log incoming HTTP requests and their responses.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request object.</p> required <code>call_next</code> <code>Callable</code> <p>The next request handler in the chain.</p> required <p>Returns:</p> Name Type Description <code>Response</code> <p>The processed HTTP response.</p> Source code in <code>itv_asset_tree/api/app.py</code> <pre><code>@app.middleware(\"http\")\nasync def log_requests(request: Request, call_next):\n    \"\"\"\n    Middleware to log incoming HTTP requests and their responses.\n\n    Args:\n        request (Request): The incoming HTTP request object.\n        call_next (Callable): The next request handler in the chain.\n\n    Returns:\n        Response: The processed HTTP response.\n    \"\"\"\n    log_info(f\"\ud83d\udce5 Incoming request: {request.method} {request.url}\")\n    response = await call_next(request)\n    log_info(f\"\ud83d\udce4 Response status: {response.status_code}\")\n    return response\n</code></pre>"},{"location":"#itv_asset_tree.api.app.startup_event","title":"<code>startup_event()</code>  <code>async</code>","text":"<p>Handles FastAPI startup event to establish a connection to Seeq.</p> <p>This function is executed when FastAPI starts to ensure that the API is logged into Seeq before handling any requests.</p> Source code in <code>itv_asset_tree/api/app.py</code> <pre><code>@app.on_event(\"startup\")\nasync def startup_event():\n    \"\"\"\n    Handles FastAPI startup event to establish a connection to Seeq.\n\n    This function is executed when FastAPI starts to ensure that the API\n    is logged into Seeq before handling any requests.\n    \"\"\"\n    log_info(\"\ud83d\ude80 FastAPI startup initiated...\")\n    connect_to_seeq()  # Connect to Seeq on startup\n</code></pre>"},{"location":"#itv_asset_tree.api.csv_lookup_generator.GenerateLookupRequest","title":"<code>GenerateLookupRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Defines metadata to generate lookup tables from CSVs.</p> Source code in <code>itv_asset_tree/api/csv_lookup_generator.py</code> <pre><code>class GenerateLookupRequest(BaseModel):\n    \"\"\"\n    Defines metadata to generate lookup tables from CSVs.\n    \"\"\"\n    group_column: str\n    key_column: str\n    value_column: str\n    output_file: str\n    content_base64: str\n</code></pre>"},{"location":"#itv_asset_tree.api.csv_lookup_generator.GetDuplicatesRequest","title":"<code>GetDuplicatesRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Contains metadata for detecting duplicates in uploaded CSVs.</p> Source code in <code>itv_asset_tree/api/csv_lookup_generator.py</code> <pre><code>class GetDuplicatesRequest(BaseModel):\n    \"\"\"\n    Contains metadata for detecting duplicates in uploaded CSVs.\n    \"\"\"\n    filename: str\n    content_base64: str\n    group_column: str\n    key_column: str\n    value_column: str\n</code></pre>"},{"location":"#itv_asset_tree.api.csv_lookup_generator.PushLookupRequest","title":"<code>PushLookupRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for pushing a lookup into Seeq.</p> <p>Attributes:</p> Name Type Description <code>tree_name</code> <code>str</code> <p>The name of the asset tree.</p> <code>workbook_name</code> <code>str</code> <p>The name of the Seeq workbook.</p> <code>content_base64</code> <code>str</code> <p>The base64-encoded CSV content representing the lookup.</p> Source code in <code>itv_asset_tree/api/csv_lookup_generator.py</code> <pre><code>class PushLookupRequest(BaseModel):\n    \"\"\"\n    Request model for pushing a lookup into Seeq.\n\n    Attributes:\n        tree_name (str): The name of the asset tree.\n        workbook_name (str): The name of the Seeq workbook.\n        content_base64 (str): The base64-encoded CSV content representing the lookup.\n    \"\"\"\n    tree_name: str\n    workbook_name: str\n</code></pre>"},{"location":"#itv_asset_tree.api.csv_lookup_generator.ResolveDuplicatesRequest","title":"<code>ResolveDuplicatesRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Used to identify and remove duplicate rows from CSVs.</p> Source code in <code>itv_asset_tree/api/csv_lookup_generator.py</code> <pre><code>class ResolveDuplicatesRequest(BaseModel):\n    \"\"\"\n    Used to identify and remove duplicate rows from CSVs.\n    \"\"\"\n    filename: str\n    content_base64: str\n    group_column: str\n    key_column: str\n    value_column: str\n    rows_to_remove: list[int] = []\n</code></pre>"},{"location":"#itv_asset_tree.api.csv_lookup_generator.SetParentPathsRequest","title":"<code>SetParentPathsRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for assigning parent paths to lookup strings.</p> Source code in <code>itv_asset_tree/api/csv_lookup_generator.py</code> <pre><code>class SetParentPathsRequest(BaseModel):\n    \"\"\"\n    Request model for assigning parent paths to lookup strings.\n    \"\"\"\n    parent_paths: Dict[str, str]\n    group_column: str\n    key_column: str\n    value_column: str\n    content_base64: str  # \u2705 Missing before \u2014 must include this!\n</code></pre>"},{"location":"#itv_asset_tree.api.csv_lookup_generator.UploadRawCsvRequest","title":"<code>UploadRawCsvRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Holds the filename and base64-encoded content for a CSV upload.</p> Source code in <code>itv_asset_tree/api/csv_lookup_generator.py</code> <pre><code>class UploadRawCsvRequest(BaseModel):\n    \"\"\"\n    Holds the filename and base64-encoded content for a CSV upload.\n    \"\"\"\n    filename: str\n    content_base64: str\n</code></pre>"},{"location":"#itv_asset_tree.api.csv_lookup_generator.generate_lookup","title":"<code>generate_lookup(request)</code>","text":"<p>Generates lookup strings from a base64-encoded CSV and saves the lookup output.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>GenerateLookupRequest</code> <p>Contains group_column, key_column, value_column, output_file name, and base64-encoded CSV content.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Contains a message, the output filename, and base64-encoded content of the lookup output CSV.</p> Source code in <code>itv_asset_tree/api/csv_lookup_generator.py</code> <pre><code>def generate_lookup(request: GenerateLookupRequest):\n    \"\"\"\n    Generates lookup strings from a base64-encoded CSV and saves the lookup output.\n\n    Args:\n        request (GenerateLookupRequest): Contains group_column, key_column, value_column,\n            output_file name, and base64-encoded CSV content.\n\n    Returns:\n        dict: Contains a message, the output filename, and base64-encoded content of the lookup output CSV.\n    \"\"\"\n    try:\n        decoded = base64.b64decode(request.content_base64)\n        df = pd.read_csv(io.BytesIO(decoded))\n\n        lookup_builder = LookupTableBuilder(request.group_column, request.key_column, request.value_column)\n        lookup_data = lookup_builder.build(df)\n\n        parent_paths = {f\"{group.replace(' ', '_')}_LookupString\": \"Set Parent Path\" for group in lookup_data.keys()}\n        output_path = os.path.join(UPLOAD_DIR, \"lookup_output.csv\")\n        lookup_builder.save_lookup_to_csv(lookup_data, parent_paths, output_path)\n\n        with open(output_path, \"rb\") as f:\n            generated_base64 = base64.b64encode(f.read()).decode()\n\n        return {\n            \"message\": f\"\u2705 Lookup file 'lookup_output.csv' created.\",\n            \"output_file\": \"lookup_output.csv\",\n            \"content_base64\": generated_base64\n        }\n    except Exception as e:\n        return {\"message\": f\"\u274c Error generating lookup: {str(e)}\", \"output_file\": None}\n</code></pre>"},{"location":"#itv_asset_tree.api.csv_lookup_generator.get_duplicates","title":"<code>get_duplicates(request)</code>","text":"<p>Finds duplicate rows in a CSV based on specified grouping and key columns.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>GetDuplicatesRequest</code> <p>Contains filename, base64 CSV content,  group_column, key_column, and value_column to identify duplicates.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Contains a message about the operation and a list of duplicate rows if any.</p> Source code in <code>itv_asset_tree/api/csv_lookup_generator.py</code> <pre><code>def get_duplicates(request: GetDuplicatesRequest):\n    \"\"\"\n    Finds duplicate rows in a CSV based on specified grouping and key columns.\n\n    Args:\n        request (GetDuplicatesRequest): Contains filename, base64 CSV content, \n            group_column, key_column, and value_column to identify duplicates.\n\n    Returns:\n        dict: Contains a message about the operation and a list of duplicate rows if any.\n    \"\"\"\n    try:\n        decoded = base64.b64decode(request.content_base64)\n        df = pd.read_csv(io.BytesIO(decoded))\n\n        missing_cols = []\n        for col in [request.group_column, request.key_column, request.value_column]:\n            if col not in df.columns:\n                missing_cols.append(col)\n\n        if missing_cols:\n            return {\n                \"message\": f\"\u274c Missing required columns: {', '.join(missing_cols)}\",\n                \"duplicates\": []\n            }\n\n        # \u2705 Correct grouping and detection logic:\n        grouped = df.groupby(request.group_column)\n\n        duplicates_list = []\n        for group_name, group_df in grouped:\n            duplicates_in_group = group_df[group_df.duplicated(subset=[request.key_column], keep=False)]\n            if not duplicates_in_group.empty:\n                duplicates_list.extend(duplicates_in_group.to_dict(orient=\"records\"))\n\n        # \u2705 Clean message reporting\n        if duplicates_list:\n            message = f\"\u2705 Found {len(duplicates_list)} duplicate rows based on '{request.group_column}' and '{request.key_column}'.\"\n        else:\n            message = \"\u2705 No duplicates found.\"\n\n        return {\n            \"message\": message,\n            \"duplicates\": duplicates_list\n        }\n\n    except Exception as e:\n        return {\n            \"message\": f\"\u274c Error finding duplicates: {str(e)}\",\n            \"duplicates\": []\n        }\n</code></pre>"},{"location":"#itv_asset_tree.api.csv_lookup_generator.get_lookup_names","title":"<code>get_lookup_names(request)</code>","text":"<p>Extracts unique lookup names from a specified group column in a base64-encoded CSV.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>dict</code> <p>Contains 'content_base64' with CSV data and 'group_column' to extract lookup names from.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Contains a message and a list of unique lookup names found in the CSV.</p> Source code in <code>itv_asset_tree/api/csv_lookup_generator.py</code> <pre><code>def get_lookup_names(request: dict):\n    \"\"\"\n    Extracts unique lookup names from a specified group column in a base64-encoded CSV.\n\n    Args:\n        request (dict): Contains 'content_base64' with CSV data and 'group_column' to extract lookup names from.\n\n    Returns:\n        dict: Contains a message and a list of unique lookup names found in the CSV.\n    \"\"\"\n\n    try:\n        # Assume the file is already uploaded or passed in memory\n        decoded = base64.b64decode(request['content_base64'])\n        df = pd.read_csv(io.BytesIO(decoded))\n\n        group_column = request.get('group_column')\n        if group_column not in df.columns:\n            return {\"message\": f\"\u274c Column '{group_column}' not found.\", \"lookup_names\": []}\n\n        lookup_names = df[group_column].dropna().unique().tolist()\n        return {\"message\": \"\u2705 Lookup names extracted.\", \"lookup_names\": lookup_names}\n\n    except Exception as e:\n        return {\"message\": f\"\u274c Error fetching lookup names: {str(e)}\", \"lookup_names\": []}\n</code></pre>"},{"location":"#itv_asset_tree.api.csv_lookup_generator.push_lookup","title":"<code>push_lookup(request)</code>","text":"<p>Pushes the lookup strings from lookup_output.csv into the Seeq asset tree.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>PushLookupRequest</code> <p>Contains the tree_name and workbook_name for Seeq.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Contains a message about the operation and the visualized tree structure if successful.</p> Source code in <code>itv_asset_tree/api/csv_lookup_generator.py</code> <pre><code>def push_lookup(request: PushLookupRequest):\n    \"\"\"\n    Pushes the lookup strings from lookup_output.csv into the Seeq asset tree.\n\n    Args:\n        request (PushLookupRequest): Contains the tree_name and workbook_name for Seeq.\n\n    Returns:\n        dict: Contains a message about the operation and the visualized tree structure if successful.\n    \"\"\"\n    try:\n        # \u2705 Load lookup_output.csv directly\n        lookup_file_path = os.path.join(\"./output\", \"lookup_output.csv\")\n        if not os.path.exists(lookup_file_path):\n            return {\n                \"message\": \"\u274c lookup_output.csv not found. Please generate it first by setting parent paths.\",\n                \"tree_structure\": None\n            }\n\n        df = pd.read_csv(lookup_file_path)\n\n        if df.empty:\n            return {\n                \"message\": \"\u274c Lookup CSV is empty.\",\n                \"tree_structure\": None\n            }\n\n        tree_modifier = TreeModifier(workbook=request.workbook_name, tree_name=request.tree_name)\n\n        for _, row in df.iterrows():\n            tree_modifier.tree.insert(children=[{\n                \"Name\": row[\"Name\"].strip(),\n                \"Formula\": row[\"Formula\"].strip(),\n                \"Formula Parameters\": json.loads(row.get(\"Formula Parameters\", \"{}\")),\n            }], parent=row[\"Parent Path\"].strip())\n\n        tree_modifier.tree.push()\n\n        global current_tree, current_tree_name\n        current_tree, current_tree_name = tree_modifier.tree, request.tree_name\n\n        visualize_output = io.StringIO()\n        with redirect_stdout(visualize_output):\n            current_tree.visualize()\n\n        return {\n            \"message\": \"\u2705 Lookup pushed to Seeq.\",\n            \"tree_structure\": visualize_output.getvalue().strip()\n        }\n    except Exception as e:\n        return {\n            \"message\": f\"\u274c Failed to push lookup: {str(e)}\",\n            \"tree_structure\": None\n        }\n</code></pre>"},{"location":"#itv_asset_tree.api.csv_lookup_generator.resolve_duplicates","title":"<code>resolve_duplicates(request)</code>","text":"<p>Removes specified rows from a CSV to resolve duplicates and saves the resolved file.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>ResolveDuplicatesRequest</code> <p>Contains filename, base64 CSV content, group_column, key_column, value_column, and a list of row indices to remove.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Contains a message about the operation and the path to the resolved CSV file if successful.</p> Source code in <code>itv_asset_tree/api/csv_lookup_generator.py</code> <pre><code>def resolve_duplicates(request: ResolveDuplicatesRequest):\n    \"\"\"\n    Removes specified rows from a CSV to resolve duplicates and saves the resolved file.\n\n    Args:\n        request (ResolveDuplicatesRequest): Contains filename, base64 CSV content,\n            group_column, key_column, value_column, and a list of row indices to remove.\n\n    Returns:\n        dict: Contains a message about the operation and the path to the resolved CSV file if successful.\n    \"\"\"\n\n    try:\n        decoded = base64.b64decode(request.content_base64)\n        df = pd.read_csv(io.BytesIO(decoded))\n\n        for column in [request.group_column, request.key_column, request.value_column]:\n            if column not in df.columns:\n                return {\"message\": f\"\u274c Column '{column}' not found.\", \"resolved_file\": None}\n\n        resolved_data = df.drop(index=request.rows_to_remove)\n\n        output_path = os.path.join(\"./output\", \"resolved_data.csv\")\n        resolved_data.to_csv(output_path, index=False)\n\n        return {\"message\": f\"\u2705 Duplicates resolved. {len(request.rows_to_remove)} rows removed.\", \"resolved_file\": output_path}\n    except Exception as e:\n        return {\"message\": f\"\u274c Error resolving duplicates: {str(e)}\", \"resolved_file\": None}\n</code></pre>"},{"location":"#itv_asset_tree.api.csv_lookup_generator.set_parent_paths","title":"<code>set_parent_paths(request)</code>","text":"<p>Sets parent paths for the lookup strings and saves the results to lookup_output.csv.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>SetParentPathsRequest</code> <p>The request containing parent path mappings, group_column, key_column, value_column, and base64-encoded CSV content.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A message indicating success or error, plus updated lookup records.</p> Source code in <code>itv_asset_tree/api/csv_lookup_generator.py</code> <pre><code>def set_parent_paths(request: SetParentPathsRequest):\n    \"\"\"\n    Sets parent paths for the lookup strings and saves the results to lookup_output.csv.\n\n    Args:\n        request (SetParentPathsRequest): The request containing parent path mappings,\n            group_column, key_column, value_column, and base64-encoded CSV content.\n\n    Returns:\n        dict: A message indicating success or error, plus updated lookup records.\n    \"\"\"\n    try:\n        resolved_path = os.path.join(UPLOAD_DIR, \"resolved_data.csv\")\n        if not os.path.exists(resolved_path):\n            return {\n                \"message\": \"\u274c Resolved data file not found.\",\n                \"updated_records\": []\n            }\n\n        data = pd.read_csv(resolved_path)\n        for column in [request.group_column, request.key_column, request.value_column]:\n            if column not in data.columns:\n                return {\n                    \"message\": f\"\u274c Column '{column}' not found.\",\n                    \"updated_records\": []\n                }\n\n        parent_paths = request.parent_paths\n        lookup_builder = LookupTableBuilder(request.group_column, request.key_column, request.value_column)\n        lookup_tables = lookup_builder.build(data)\n\n        lookup_data = [\n            {\n                \"Name\": f\"{name.replace(' ', '_')}_LookupString\",\n                \"Formula\": '\"' + str(formula).replace('\"', \"'\") + '\"',\n                \"Formula Parameters\": \"{}\",\n                \"Parent Path\": parent_paths.get(name, \"Root Asset\"),\n            }\n            for name, formula in lookup_tables.items()\n        ]\n\n        output_file = os.path.join(UPLOAD_DIR, \"lookup_output.csv\")\n        pd.DataFrame(lookup_data).to_csv(output_file, index=False)\n\n        return {\n            \"message\": f\"\u2705 Successfully set parent paths for {len(parent_paths)} lookup strings.\",\n            \"updated_records\": lookup_data\n        }\n    except Exception as e:\n        return {\n            \"message\": f\"\u274c Error setting parent paths: {str(e)}\",\n            \"updated_records\": []\n        }\n</code></pre>"},{"location":"#itv_asset_tree.api.csv_lookup_generator.upload_raw_csv","title":"<code>upload_raw_csv(request)</code>","text":"<p>Uploads and validates a raw CSV file from Base64-encoded content.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>UploadRawCsvRequest</code> <p>The upload request containing filename and content.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A success message or error details.</p> Source code in <code>itv_asset_tree/api/csv_lookup_generator.py</code> <pre><code>def upload_raw_csv(request: UploadRawCsvRequest):\n    \"\"\"\n    Uploads and validates a raw CSV file from Base64-encoded content.\n\n    Args:\n        request (UploadRawCsvRequest): The upload request containing filename and content.\n\n    Returns:\n        dict: A success message or error details.\n    \"\"\"\n    try:\n        decoded_content = base64.b64decode(request.content_base64)\n        file_path = os.path.join(UPLOAD_DIR, request.filename)\n        with open(file_path, \"wb\") as f:\n            f.write(decoded_content)\n\n        pd.read_csv(file_path)\n        return {\"message\": f\"\u2705 File '{request.filename}' uploaded successfully.\"}\n    except Exception as e:\n        return {\"message\": f\"\u274c Failed to upload CSV: {str(e)}\"}\n</code></pre>"},{"location":"#itv_asset_tree.api.dependencies.get_db","title":"<code>get_db()</code>","text":"<p>Dependency function that provides a database session.</p> <p>This function yields a database session for use in API routes. The session is automatically closed after use.</p> <p>Yields:</p> Name Type Description <code>Session</code> <p>A SQLAlchemy database session instance.</p> Source code in <code>itv_asset_tree/api/dependencies.py</code> <pre><code>def get_db():\n    \"\"\"\n    Dependency function that provides a database session.\n\n    This function yields a database session for use in API routes.\n    The session is automatically closed after use.\n\n    Yields:\n        Session: A SQLAlchemy database session instance.\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n</code></pre>"},{"location":"#itv_asset_tree.api.models.BuildRequest","title":"<code>BuildRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request model for building an asset template.</p> Source code in <code>itv_asset_tree/api/models.py</code> <pre><code>class BuildRequest(BaseModel):\n    \"\"\"\n    Request model for building an asset template.\n    \"\"\"\n    template_name: str = Field(..., description=\"The name of the template to apply\")\n    type: Optional[str] = Field(..., description=\"The type of signal (StoredSignal, CalculatedSignal, etc.)\")\n    search_query: Optional[str] = Field(None, description=\"Query used to find matching signals\")\n    build_asset_regex: str = Field(..., description=\"Regex to extract asset names from signals\")\n    build_path: Optional[str] = Field(..., description=\"Path where the asset should be built\")\n\n    # Conditionally Required Fields\n    datasource_name: Optional[str] = Field(None, description=\"Datasource Name (Only required for Stored Signals)\")\n    path: Optional[str] = Field(None, description=\"Asset tree path for searching signals\")\n\n    # Contextual Fields\n    workbook_name: Optional[str] = Field(None, description=\"Workbook Name (Required for Seeq push)\")\n    facility_name: Optional[str] = Field(None, description=\"Directly assigned Facility Name\")\n    section_name_regex: Optional[str] = Field(None, description=\"Regex to extract Section names from signals\")\n    region_name: Optional[str] = Field(None, description=\"Directly assigned Region Name\")\n</code></pre>"},{"location":"#itv_asset_tree.api.startup_handler.connect_to_seeq","title":"<code>connect_to_seeq()</code>","text":"<p>Establishes a connection to Seeq using credentials from environment variables (via settings).</p> Source code in <code>itv_asset_tree/api/startup_handler.py</code> <pre><code>def connect_to_seeq():\n    \"\"\"\n    Establishes a connection to Seeq using credentials from environment variables (via settings).\n    \"\"\"\n    # Retrieve values directly from the settings object (which is populated from .env)\n    server_url = settings.SERVER_HOST  # Directly access .env variable\n    username = settings.SERVER_USERNAME\n    password = settings.SERVER_PASSWORD\n    force_login = settings.SEEQ_FORCE_LOGIN  # Default is set in config.py\n\n    login_kwargs = {\n        \"url\": server_url,\n        \"username\": username,\n        \"password\": password,\n        \"force\": force_login  # Use .env value for force login\n    }\n\n    # log_info(f\"Attempting to log in with username: {username}, server: {server_url}\")\n\n    # Clean up empty values and attempt to login\n    login_kwargs = {k: v for k, v in login_kwargs.items() if v}\n\n    try:\n        spy.login(**login_kwargs)  # Log into Seeq\n        host = \"127.0.0.1\"\n        port = 8000  # Default port\n        log_info(\"\u2705 Successfully logged into Seeq and Config Loaded!\")\n        log_info(f\"\ud83d\ude80 Server is running! Click here to open: http://{host}:{port}\")\n    except Exception as e:\n        log_info(f\"\u274c Failed to log in to Seeq: {str(e)}\")\n</code></pre>"},{"location":"#itv_asset_tree.api.startup_handler.ensure_user_config","title":"<code>ensure_user_config()</code>","text":"<p>Ensure that the user's local configuration directory exists and is populated.</p> <p>Copies the default <code>config.yaml</code> and <code>templates</code> directory from the package to the user's home directory under <code>.itv_asset_tree</code>, if they do not already exist.</p> <p>Logs relevant status messages throughout the process.</p> Source code in <code>itv_asset_tree/api/startup_handler.py</code> <pre><code>def ensure_user_config():\n    \"\"\"\n    Ensure that the user's local configuration directory exists and is populated.\n\n    Copies the default `config.yaml` and `templates` directory from the package to the user's\n    home directory under `.itv_asset_tree`, if they do not already exist.\n\n    Logs relevant status messages throughout the process.\n    \"\"\"\n    user_config_dir = Path.home() / \".itv_asset_tree\"\n    package_config_dir = Path(__file__).parent.parent / \"config\"\n    package_templates_dir = Path(__file__).parent.parent / \"templates\"\n\n    log_info(f\"Checking user config directory at: {user_config_dir}\")\n\n    # Ensure user config directory exists\n    user_config_dir.mkdir(parents=True, exist_ok=True)\n\n    # Copy config.yaml if it doesn't exist\n    config_path = user_config_dir / \"config.yaml\"\n    if not config_path.exists():\n        if (package_config_dir / \"config.yaml\").exists():\n            shutil.copy(package_config_dir / \"config.yaml\", config_path)\n            log_info(f\"\u2705 Copied config.yaml to {config_path}\")\n        else:\n            log_info(f\"\u26a0\ufe0f Package config.yaml not found at {package_config_dir}\")\n\n    # Copy templates directory if it doesn't exist\n    user_templates_dir = user_config_dir / \"templates\"\n    if not user_templates_dir.exists():\n        if package_templates_dir.exists():\n            shutil.copytree(package_templates_dir, user_templates_dir, dirs_exist_ok=True)\n            log_info(f\"\u2705 Copied templates to {user_templates_dir}\")\n        else:\n            log_info(f\"\u26a0\ufe0f Package templates directory not found at {package_templates_dir}\")\n\n    log_info(f\"Final User Config Path: {user_config_dir}\")\n    log_info(f\"Final User Templates Path: {user_templates_dir}\")\n</code></pre>"},{"location":"#itv_asset_tree.api.template_discovery.TemplateListResponse","title":"<code>TemplateListResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response model for listing available templates.</p> <p>Attributes:</p> Name Type Description <code>templates</code> <code>List[str]</code> <p>Enabled template names from config.yaml.</p> Source code in <code>itv_asset_tree/api/template_discovery.py</code> <pre><code>class TemplateListResponse(BaseModel):\n    \"\"\"\n    Response model for listing available templates.\n\n    Attributes:\n        templates (List[str]): Enabled template names from config.yaml.\n    \"\"\"\n    templates: List[str]\n</code></pre>"},{"location":"#itv_asset_tree.api.template_discovery.get_templates","title":"<code>get_templates()</code>","text":"<p>Retrieves the list of enabled asset tree templates from config.yaml.</p> <p>Returns:</p> Name Type Description <code>TemplateListResponse</code> <code>TemplateListResponse</code> <p>Object containing template names.</p> Source code in <code>itv_asset_tree/api/template_discovery.py</code> <pre><code>def get_templates() -&gt; TemplateListResponse:\n    \"\"\"\n    Retrieves the list of enabled asset tree templates from config.yaml.\n\n    Returns:\n        TemplateListResponse: Object containing template names.\n    \"\"\"\n    templates = get_config_value(\"templates.enabled\", [])\n    return TemplateListResponse(templates=templates)\n</code></pre>"},{"location":"#itv_asset_tree.api.templates.build_template_endpoint","title":"<code>build_template_endpoint(request)</code>","text":"<p>Route for building an asset tree using the requested template.</p> <p>Dynamically resolves the appropriate entry class and delegates the build process to the correct strategy (HVAC-style or Valve-style).</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>BuildRequest</code> <p>Request payload with all required fields.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Message indicating result of build and push.</p> Source code in <code>itv_asset_tree/api/templates.py</code> <pre><code>def build_template_endpoint(request: BuildRequest):\n    \"\"\"\n    Route for building an asset tree using the requested template.\n\n    Dynamically resolves the appropriate entry class and delegates the build process\n    to the correct strategy (HVAC-style or Valve-style).\n\n    Args:\n        request (BuildRequest): Request payload with all required fields.\n\n    Returns:\n        dict: Message indicating result of build and push.\n    \"\"\"\n    try:\n        log_info(f\"\ud83d\udd0d Received request: {request.dict()}\")\n\n        # Get template entry class\n        template_entry = TEMPLATE_ENTRY_POINTS.get(request.template_name)\n        if not template_entry:\n            return {\n                \"status\": 400,\n                \"statusMessage\": f\"\ud83d\udea8 Unknown template: {request.template_name}\"\n            }\n\n        log_info(f\"\u2705 Resolved template entry: {template_entry.__name__} (from template: {request.template_name})\")\n\n        # Decide build style from config\n        build_config = {}\n        try:\n            build_config = template_entry.get_build_config()  # type: ignore[attr-defined]\n        except Exception as e:\n            log_info(f\"\u26a0\ufe0f No get_build_config() available: {e}\")\n\n        requires_component_column = build_config.get(\"requires_component_column\", True)\n        log_info(f\"\ud83d\udce6 requires_component_column: {requires_component_column}\")\n\n        build_df = build_template(request, template_entry)\n\n        log_info(\"\u2705 Successfully built and pushed asset tree.\")\n        return {\"message\": \"\u2705 Successfully built and pushed asset tree.\"}\n\n    except Exception as e:\n        log_error(f\"\u274c Error in build_template_endpoint: {str(e)}\\n{traceback.format_exc()}\")\n        return {\n            \"status\": 500,\n            \"statusMessage\": \"\u274c Failed to build asset tree.\"\n        }\n</code></pre>"},{"location":"#itv_asset_tree.api.templates.extract_asset_name","title":"<code>extract_asset_name(row)</code>","text":"<p>Extracts the asset name from the signal name based on the component. Args:     row (pd.Series): A row from the DataFrame containing 'Name' and 'Component'. Returns:     str: The extracted asset name.</p> Source code in <code>itv_asset_tree/api/templates.py</code> <pre><code>def extract_asset_name(row):\n    \"\"\"\n    Extracts the asset name from the signal name based on the component.\n    Args:\n        row (pd.Series): A row from the DataFrame containing 'Name' and 'Component'.\n    Returns:\n        str: The extracted asset name.\n    \"\"\"\n    log_info(f\"\ud83d\udd0d Extracting asset name from row: {row}\")\n    name = row[\"Name\"]\n    component = row[\"Component\"]\n    if pd.isna(component):\n        return name  # fallback\n    try:\n        parts = name.split(component, 1)\n        suffix = parts[1] if len(parts) &gt; 1 else name\n        log_info(f\"\u2705 Extracted asset name: {suffix.strip('_- ')}\")\n        return suffix.strip(\"_- \") or name\n    except Exception:\n        return name\n</code></pre>"},{"location":"#itv_asset_tree.api.templates.fetch_base_metadata","title":"<code>fetch_base_metadata(request)</code>","text":"<p>Retrieves base metadata from Seeq before applying calculations.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>BaseModel</code> <p>The request containing search parameters.</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>A pandas DataFrame containing metadata of matching signals.</p> Source code in <code>itv_asset_tree/api/templates.py</code> <pre><code>def fetch_base_metadata(request: BuildRequest):\n    \"\"\"\n    Retrieves base metadata from Seeq before applying calculations.\n\n    Args:\n        request (BaseModel): The request containing search parameters.\n\n    Returns:\n        DataFrame: A pandas DataFrame containing metadata of matching signals.\n    \"\"\"\n    region_name = request.region_name if request.region_name else request.build_path.split(\"&gt;&gt;\")[0].strip()\n    facility_name = request.facility_name if request.facility_name else (\n        request.build_path.split(\"&gt;&gt;\")[1].strip() if \"&gt;&gt;\" in request.build_path else None\n    )\n\n    query_payload = {\n        \"Name\": request.search_query,\n        \"Type\": \"StoredSignal\",\n        \"Datasource Name\": request.datasource_name\n    }\n\n    log_info(f\"\ud83d\udd0e Fetching base metadata with: {query_payload}\")\n    search_results = spy.search(query_payload)\n\n    if search_results.empty:\n        log_warning(f\"\u26a0\ufe0f No matching stored signals found for '{request.template_name}'.\")\n        return pd.DataFrame()\n\n    search_results = search_results[[\"ID\", \"Name\", \"Datasource Name\"]]\n\n    # Apply regex safely\n    if request.build_asset_regex:\n        extracted_asset = search_results[\"Name\"].str.extract(rf'({request.build_asset_regex})')\n        search_results[\"Build Asset\"] = extracted_asset[0]\n    else:\n        search_results[\"Build Asset\"] = None\n\n    search_results[\"Build Path\"] = f\"{region_name} &gt;&gt; {facility_name}\" if facility_name else region_name\n\n    return search_results\n</code></pre>"},{"location":"#itv_asset_tree.api.templates.fetch_existing_tree","title":"<code>fetch_existing_tree(request)</code>","text":"<p>Fetches an existing asset tree from Seeq.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>BaseModel</code> <p>The request containing asset tree details.</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>A pandas DataFrame containing the asset tree details.</p> Source code in <code>itv_asset_tree/api/templates.py</code> <pre><code>def fetch_existing_tree(request: BuildRequest):\n    \"\"\"\n    Fetches an existing asset tree from Seeq.\n\n    Args:\n        request (BaseModel): The request containing asset tree details.\n\n    Returns:\n        DataFrame: A pandas DataFrame containing the asset tree details.\n    \"\"\"\n    tree_query = {\n        \"Name\": request.asset_tree_name or request.build_path, \n        \"Type\": \"Asset\"\n    }\n\n    log_info(f\"\ud83d\udd0e Searching for existing asset tree: {tree_query}\")\n    tree_results = spy.search(tree_query)\n\n    if tree_results.empty:\n        log_warning(f\"\u26a0\ufe0f No existing asset tree found for '{tree_query['Name']}'!\")\n        return pd.DataFrame()\n\n    log_info(f\"\u2705 Found asset tree:\\n{tree_results}\")\n    return tree_results\n</code></pre>"},{"location":"#itv_asset_tree.api.templates.fetch_signals","title":"<code>fetch_signals(search_query, datasource_name=None, path=None)</code>  <code>async</code>","text":"<p>Fetches available signals from Seeq based on either: - Datasource name (raw tag search with regex filtering), or - Asset tree path (structured friendly names search).</p> <p>Parameters:</p> Name Type Description Default <code>search_query</code> <code>str</code> <p>The query string (can be regex).</p> required <code>datasource_name</code> <code>Optional[str]</code> <p>Name of the Seeq datasource.</p> <code>None</code> <code>path</code> <code>Optional[str]</code> <p>Asset tree path to search under.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>{ \"signals\": List[str] }</p> Source code in <code>itv_asset_tree/api/templates.py</code> <pre><code>async def fetch_signals(\n    search_query: str,\n    datasource_name: Optional[str] = None,\n    path: Optional[str] = None\n):\n    \"\"\"\n    Fetches available signals from Seeq based on either:\n    - Datasource name (raw tag search with regex filtering), or\n    - Asset tree path (structured friendly names search).\n\n    Args:\n        search_query (str): The query string (can be regex).\n        datasource_name (Optional[str]): Name of the Seeq datasource.\n        path (Optional[str]): Asset tree path to search under.\n\n    Returns:\n        dict: { \"signals\": List[str] }\n    \"\"\"\n    try:\n        if not datasource_name and not path:\n            return {\n                \"status\": 400,\n                \"statusMessage\": \"\u274c You must provide either a `datasource_name` or an asset tree `path`.\"\n            }\n\n        if path:\n            log_info(f\"\ud83c\udf32 Searching for signals in asset tree path: {path}\")\n\n            split_path = [p.strip() for p in path.split(\"&gt;&gt;\")]\n            if len(split_path) &lt; 2:\n                return {\n                    \"status\": 400,\n                    \"statusMessage\": \"Invalid tree path format. Expected: 'Workbook &gt;&gt; Tree Name'\"\n                }\n\n            workbook_name = \" &gt;&gt; \".join(split_path[:-1])\n            tree_name = split_path[-1]\n\n            tree = Tree(tree_name, workbook=workbook_name)\n            tree_df = tree.df\n\n            signal_df = tree_df[tree_df[\"Type\"].isin([\"Signal\", \"CalculatedSignal\", \"StoredSignal\"])]\n            matched = signal_df[signal_df[\"Name\"].str.contains(search_query, regex=True, case=False)]\n\n            log_info(f\"\u2705 Found {len(matched)} signal(s) in asset tree path search\")\n            return {\"signals\": matched[\"Name\"].tolist()}\n\n        else:\n            log_info(f\"\ud83d\udce1 Fetching raw signals from datasource: '{datasource_name}' using query: '{search_query}'\")\n\n            query = {\n                \"Type\": \"StoredSignal\",\n                \"Datasource Name\": datasource_name,\n                \"Name\": search_query\n            }\n\n            search_results = spy.search(query)\n\n            if search_results.empty:\n                log_warning(\"\u26a0\ufe0f No signals found for datasource criteria.\")\n                return {\"signals\": []}\n\n            signal_names = search_results[\"Name\"].tolist()\n            log_info(f\"\u2705 Found {len(signal_names)} signals matching search query in datasource '{datasource_name}'\")\n            return {\"signals\": signal_names}\n\n    except Exception as e:\n        import traceback\n        return {\n            \"status\": 500,\n            \"statusMessage\": f\"\u274c Failed to fetch signals: {str(e)}\",\n            \"errorType\": type(e).__name__,\n            \"trace\": traceback.format_exc()\n        }\n</code></pre>"},{"location":"#itv_asset_tree.api.templates.get_hierarchical_templates","title":"<code>get_hierarchical_templates()</code>  <code>async</code>","text":"<p>Fetches hierarchical templates that contain nested asset components.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary of hierarchical templates.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an error occurs while fetching templates.</p> Source code in <code>itv_asset_tree/api/templates.py</code> <pre><code>async def get_hierarchical_templates():\n    \"\"\"\n    Fetches hierarchical templates that contain nested asset components.\n\n    Returns:\n        dict: A dictionary of hierarchical templates.\n\n    Raises:\n        Exception: If an error occurs while fetching templates.\n    \"\"\"\n    try:\n        log_info(\"\ud83d\udd0d Fetching hierarchical templates...\")\n\n        hierarchical_templates = {\n            name for name, cls in TEMPLATE_CLASSES.items() if hasattr(cls, \"build_components\")\n        }\n\n        if not hierarchical_templates:\n            log_warning(\"\u26a0\ufe0f No hierarchical templates found.\")\n\n        log_info(f\"\u2705 Hierarchical templates retrieved: {hierarchical_templates}\")\n        return {\"hierarchical_templates\": list(hierarchical_templates)}\n\n    except Exception as e:\n        log_error(f\"\u274c Error fetching hierarchical templates: {e}\")\n        return {\n            \"status\": 500,\n            \"statusMessage\": f\"\u274c Failed to fetch hierarchical templates: {str(e)}\"\n        }\n</code></pre>"},{"location":"#itv_asset_tree.api.templates.get_template_parameters","title":"<code>get_template_parameters(template_name)</code>  <code>async</code>","text":"<p>Returns required parameters for the given template.</p> <p>Parameters:</p> Name Type Description Default <code>template_name</code> <code>str</code> <p>The name of the template.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The required parameters for the template.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the template is not found.</p> Source code in <code>itv_asset_tree/api/templates.py</code> <pre><code>async def get_template_parameters(template_name: str):\n    \"\"\"\n    Returns required parameters for the given template.\n\n    Args:\n        template_name (str): The name of the template.\n\n    Returns:\n        dict: The required parameters for the template.\n\n    Raises:\n        Exception: If the template is not found.\n    \"\"\"\n    try:\n        template_class = TEMPLATE_ENTRY_POINTS.get(template_name)\n        if not template_class:\n            return {\n                \"status\": 404,\n                \"statusMessage\": f\"\u274c Template '{template_name}' not found.\"\n            }\n\n        return {\n            \"template_name\": template_name,\n            \"required_parameters\": template_class.get_required_parameters()\n        }\n    except Exception as e:\n        return {\"error\": str(e)}\n</code></pre>"},{"location":"#itv_asset_tree.api.templates.visualize_template","title":"<code>visualize_template(params)</code>  <code>async</code>","text":"<p>Fetches and returns a structured tree visualization using TreeVisualizer.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>dict</code> <p>Dictionary containing 'workbook_name' (or 'workbookName') and optionally 'region_name' (or 'regionName').</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A message and tree structure visualization (or empty if not found).</p> Source code in <code>itv_asset_tree/api/templates.py</code> <pre><code>async def visualize_template(params: dict):\n    \"\"\"\n    Fetches and returns a structured tree visualization using TreeVisualizer.\n\n    Args:\n        params (dict): Dictionary containing 'workbook_name' (or 'workbookName') and optionally 'region_name' (or 'regionName').\n\n    Returns:\n        dict: A message and tree structure visualization (or empty if not found).\n    \"\"\"\n    try:\n        workbook_name = params.get(\"workbook_name\") or params.get(\"workbookName\")\n        region_name = params.get(\"region_name\") or params.get(\"regionName\")\n\n        log_info(f\"\ud83d\udd0d [DEBUG] Fetching visualization for Workbook: '{workbook_name}', Region Name: '{region_name}'\")\n\n        if not workbook_name:\n            return {\n                \"status\": 400,\n                \"statusMessage\": \"\u274c Missing workbook_name\",\n                \"tree_structure\": \"\"\n            }\n\n        if not region_name or not str(region_name).strip():\n            log_warning(\"\u26a0\ufe0f No region name provided, attempting to infer...\")\n            parts = workbook_name.split(\"&gt;&gt;\") if workbook_name else []\n            region_name = parts[0].strip() if len(parts) &gt; 1 else (workbook_name.strip() if workbook_name else None)\n\n        if not region_name:\n            return {\n                \"status\": 400,\n                \"statusMessage\": \"\u274c Cannot visualize tree: No valid region_name.\",\n                \"tree_structure\": \"\"\n            }\n\n        visualizer = TreeVisualizer()\n        visualization = visualizer.get_tree_visualization(tree_name=region_name, workbook_name=workbook_name)\n\n        if not visualization:\n            return {\n                \"status\": 404,\n                \"statusMessage\": f\"\u274c Visualization for tree '{region_name}' is empty or not found.\",\n                \"tree_structure\": \"\"\n            }\n\n        log_info(f\"\ud83d\udcca [DEBUG] Successfully visualized tree '{region_name}'\")\n        return {\n            \"status\": 200,\n            \"statusMessage\": f\"\u2705 Tree visualization for '{region_name}' retrieved.\",\n            \"tree_structure\": visualization\n        }\n\n    except Exception as e:\n        log_error(f\"\u274c Failed to visualize tree: {e}\")\n        return {\n            \"status\": 500,\n            \"statusMessage\": f\"\u274c Unexpected error during visualization: {str(e)}\",\n            \"errorType\": type(e).__name__,\n            \"trace\": traceback.format_exc(),\n            \"tree_structure\": \"\"\n        }\n</code></pre>"},{"location":"#itv_asset_tree.config.settings.Settings","title":"<code>Settings</code>","text":"<p>               Bases: <code>BaseSettings</code></p> <p>Configuration settings for the ITV Asset Tree API.</p> <p>Attributes:</p> Name Type Description <code>app_name</code> <code>str</code> <p>The name of the application.</p> <code>debug</code> <code>bool</code> <p>Flag to enable or disable debug mode.</p> <code>SERVER_USERNAME</code> <code>str</code> <p>Username for server authentication.</p> <code>SERVER_PASSWORD</code> <code>str</code> <p>Password for server authentication.</p> <code>SERVER_HOST</code> <code>str</code> <p>Host address of the server.</p> Source code in <code>itv_asset_tree/config/settings.py</code> <pre><code>class Settings(BaseSettings):\n    \"\"\"\n    Configuration settings for the ITV Asset Tree API.\n\n    Attributes:\n        app_name (str): The name of the application.\n        debug (bool): Flag to enable or disable debug mode.\n        SERVER_USERNAME (str): Username for server authentication.\n        SERVER_PASSWORD (str): Password for server authentication.\n        SERVER_HOST (str): Host address of the server.\n    \"\"\"\n    app_name: str = \"ITV Asset Tree API\"\n    debug: bool = False\n\n    SERVER_USERNAME: str\n    SERVER_PASSWORD: str\n    SERVER_HOST: str\n    SEEQ_FORCE_LOGIN: bool = True\n</code></pre>"},{"location":"#itv_asset_tree.core.config_loader.get_config_value","title":"<code>get_config_value(key, default=None)</code>","text":"<p>Get configuration value, prioritizing .env over YAML. - If key exists in .env, it takes precedence. - Otherwise, falls back to <code>config.yaml</code>.</p> Source code in <code>itv_asset_tree/core/config_loader.py</code> <pre><code>def get_config_value(key, default=None):\n    \"\"\"\n    Get configuration value, prioritizing .env over YAML.\n    - If key exists in .env, it takes precedence.\n    - Otherwise, falls back to `config.yaml`.\n    \"\"\"\n    # First, check for the value in the .env\n    env_value = os.getenv(key)\n\n    if env_value is not None:\n        if env_value.lower() in [\"true\", \"false\"]:\n            return env_value.lower() == \"true\"\n        if env_value.isdigit():\n            return int(env_value)\n        return env_value  # Return string as-is\n\n    # If not found in .env, fall back to config.yaml\n    keys = key.split(\".\")\n    value = config\n    for k in keys:\n        if isinstance(value, dict):\n            value = value.get(k, default)\n        else:\n            return default  # Invalid path, return default\n\n    return value\n</code></pre>"},{"location":"#itv_asset_tree.core.config_loader.load_config","title":"<code>load_config()</code>","text":"<p>Load configuration from YAML file, with fallback to defaults.</p> Source code in <code>itv_asset_tree/core/config_loader.py</code> <pre><code>def load_config():\n    \"\"\"Load configuration from YAML file, with fallback to defaults.\"\"\"\n    try:\n        if not os.path.exists(CONFIG_PATH):\n            log_info(f\"\u26a0\ufe0f config.yaml not found at {CONFIG_PATH}. Using default config.\")\n            return DEFAULT_CONFIG\n\n        with open(CONFIG_PATH, \"r\") as file:\n            config = yaml.safe_load(file) or {}\n            log_info(f\"\u2705 Config loaded successfully from {CONFIG_PATH}\")\n            return config\n    except Exception as e:\n        log_error(f\"\u274c Failed to load config: {e}\")\n        return DEFAULT_CONFIG\n</code></pre>"},{"location":"#itv_asset_tree.core.csv_parser.CSVParser","title":"<code>CSVParser</code>","text":"<p>Handles CSV file parsing and validation.</p> <p>This class provides methods to read CSV files and ensure they meet expected structural requirements before further processing.</p> Source code in <code>itv_asset_tree/core/csv_parser.py</code> <pre><code>class CSVParser:\n    \"\"\"\n    Handles CSV file parsing and validation.\n\n    This class provides methods to read CSV files and ensure they meet\n    expected structural requirements before further processing.\n    \"\"\"\n    @staticmethod\n    def parse_csv(file_path: str) -&gt; pd.DataFrame:\n        \"\"\"\n        Loads a CSV file into a pandas DataFrame and validates required columns.\n\n        Args:\n            file_path (str): The path to the CSV file.\n\n        Returns:\n            pd.DataFrame: A DataFrame containing the parsed CSV data.\n\n        Raises:\n            ValueError: If the required 'Level 1' column is missing.\n        \"\"\"\n        data = pd.read_csv(file_path)\n        if \"Level 1\" not in data.columns:\n            raise ValueError(\"\u26a0\ufe0f CSV file must contain a 'Level 1' column.\")\n        return data\n</code></pre>"},{"location":"#itv_asset_tree.core.csv_parser.CSVParser.parse_csv","title":"<code>parse_csv(file_path)</code>  <code>staticmethod</code>","text":"<p>Loads a CSV file into a pandas DataFrame and validates required columns.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the CSV file.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the parsed CSV data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the required 'Level 1' column is missing.</p> Source code in <code>itv_asset_tree/core/csv_parser.py</code> <pre><code>@staticmethod\ndef parse_csv(file_path: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Loads a CSV file into a pandas DataFrame and validates required columns.\n\n    Args:\n        file_path (str): The path to the CSV file.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the parsed CSV data.\n\n    Raises:\n        ValueError: If the required 'Level 1' column is missing.\n    \"\"\"\n    data = pd.read_csv(file_path)\n    if \"Level 1\" not in data.columns:\n        raise ValueError(\"\u26a0\ufe0f CSV file must contain a 'Level 1' column.\")\n    return data\n</code></pre>"},{"location":"#itv_asset_tree.core.interfaces.ITreeArchive","title":"<code>ITreeArchive</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Interface for archiving entire asset trees.</p> <p>This interface enforces the implementation of a tree-level archival operation.</p> Source code in <code>itv_asset_tree/core/interfaces.py</code> <pre><code>class ITreeArchive(ABC):\n    \"\"\"\n    Interface for archiving entire asset trees.\n\n    This interface enforces the implementation of a tree-level archival operation.\n    \"\"\"\n    @abstractmethod\n    def archive(self):\n        \"\"\"\n        Archives all items in the associated asset tree.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"#itv_asset_tree.core.interfaces.ITreeArchive.archive","title":"<code>archive()</code>  <code>abstractmethod</code>","text":"<p>Archives all items in the associated asset tree.</p> Source code in <code>itv_asset_tree/core/interfaces.py</code> <pre><code>@abstractmethod\ndef archive(self):\n    \"\"\"\n    Archives all items in the associated asset tree.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#itv_asset_tree.core.interfaces.ITreeInsert","title":"<code>ITreeInsert</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Interface for inserting items into an asset tree.</p> <p>This interface defines the required method for inserting an item under a specified parent path.</p> Source code in <code>itv_asset_tree/core/interfaces.py</code> <pre><code>class ITreeInsert(ABC):\n    \"\"\"\n    Interface for inserting items into an asset tree.\n\n    This interface defines the required method for inserting an item under a specified parent path.\n    \"\"\"\n    @abstractmethod\n    def insert_item(self, parent_path: str, item_definition: dict):\n        \"\"\"\n        Inserts an item into the tree under the specified parent path.\n\n        Args:\n            parent_path (str): The path of the parent node where the item should be inserted.\n            item_definition (dict): A dictionary defining the item's attributes.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"#itv_asset_tree.core.interfaces.ITreeInsert.insert_item","title":"<code>insert_item(parent_path, item_definition)</code>  <code>abstractmethod</code>","text":"<p>Inserts an item into the tree under the specified parent path.</p> <p>Parameters:</p> Name Type Description Default <code>parent_path</code> <code>str</code> <p>The path of the parent node where the item should be inserted.</p> required <code>item_definition</code> <code>dict</code> <p>A dictionary defining the item's attributes.</p> required Source code in <code>itv_asset_tree/core/interfaces.py</code> <pre><code>@abstractmethod\ndef insert_item(self, parent_path: str, item_definition: dict):\n    \"\"\"\n    Inserts an item into the tree under the specified parent path.\n\n    Args:\n        parent_path (str): The path of the parent node where the item should be inserted.\n        item_definition (dict): A dictionary defining the item's attributes.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#itv_asset_tree.core.interfaces.ITreeMove","title":"<code>ITreeMove</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Interface for moving items within an asset tree.</p> <p>This interface enforces the implementation of item movement between tree locations.</p> Source code in <code>itv_asset_tree/core/interfaces.py</code> <pre><code>class ITreeMove(ABC):\n    \"\"\"\n    Interface for moving items within an asset tree.\n\n    This interface enforces the implementation of item movement between tree locations.\n    \"\"\"\n    @abstractmethod\n    def move_item(self, source: str, destination: str):\n        \"\"\"\n        Moves an item from the source path to the destination path.\n\n        Args:\n            source (str): The current location of the item in the tree.\n            destination (str): The new location where the item should be moved.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"#itv_asset_tree.core.interfaces.ITreeMove.move_item","title":"<code>move_item(source, destination)</code>  <code>abstractmethod</code>","text":"<p>Moves an item from the source path to the destination path.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The current location of the item in the tree.</p> required <code>destination</code> <code>str</code> <p>The new location where the item should be moved.</p> required Source code in <code>itv_asset_tree/core/interfaces.py</code> <pre><code>@abstractmethod\ndef move_item(self, source: str, destination: str):\n    \"\"\"\n    Moves an item from the source path to the destination path.\n\n    Args:\n        source (str): The current location of the item in the tree.\n        destination (str): The new location where the item should be moved.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#itv_asset_tree.core.interfaces.ITreeRemove","title":"<code>ITreeRemove</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Interface for removing items from an asset tree.</p> <p>This interface enforces the implementation of item deletion within a tree structure.</p> Source code in <code>itv_asset_tree/core/interfaces.py</code> <pre><code>class ITreeRemove(ABC):\n    \"\"\"\n    Interface for removing items from an asset tree.\n\n    This interface enforces the implementation of item deletion within a tree structure.\n    \"\"\"\n    @abstractmethod\n    def remove_item(self, item_path: str):\n        \"\"\"\n        Removes an item from the tree at the specified path.\n\n        Args:\n            item_path (str): The path of the item to be removed.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"#itv_asset_tree.core.interfaces.ITreeRemove.remove_item","title":"<code>remove_item(item_path)</code>  <code>abstractmethod</code>","text":"<p>Removes an item from the tree at the specified path.</p> <p>Parameters:</p> Name Type Description Default <code>item_path</code> <code>str</code> <p>The path of the item to be removed.</p> required Source code in <code>itv_asset_tree/core/interfaces.py</code> <pre><code>@abstractmethod\ndef remove_item(self, item_path: str):\n    \"\"\"\n    Removes an item from the tree at the specified path.\n\n    Args:\n        item_path (str): The path of the item to be removed.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#itv_asset_tree.core.push_manager.PushManager","title":"<code>PushManager</code>","text":"<p>Handles pushing an asset tree to Seeq using different push strategies.</p> <p>This class manages the process of pushing a tree using a specified strategy, allowing for flexibility in how the push operation is executed.</p> Source code in <code>itv_asset_tree/core/push_manager.py</code> <pre><code>class PushManager:\n    \"\"\"\n    Handles pushing an asset tree to Seeq using different push strategies.\n\n    This class manages the process of pushing a tree using a specified strategy,\n    allowing for flexibility in how the push operation is executed.\n    \"\"\"\n    def __init__(self, tree, strategy: PushStrategy = None):\n        \"\"\"\n        Initializes the PushManager with an asset tree and a push strategy.\n\n        Args:\n            tree: The asset tree to be pushed.\n            strategy (PushStrategy, optional): The strategy to use for pushing the tree.\n                Defaults to `ImmediatePush` if no strategy is provided.\n\n        Raises:\n            ValueError: If the provided tree is empty or invalid.\n        \"\"\"\n        if not tree:\n            raise ValueError(\"\u274c PushManager received an empty tree.\")\n\n        log_debug(f\"\u2705 [DEBUG] PushManager initialized with tree '{tree.name}'.\")\n\n        self.tree = tree\n        self.strategy = strategy if strategy else ImmediatePush()  # Default strategy\n\n    def push(self, metadata_state_file=None, metadata_df=None):\n        \"\"\"\n        Executes the push operation using the assigned push strategy, or pushes metadata directly.\n\n        Args:\n            metadata_state_file (str, optional): Path to metadata state file.\n            metadata_df (pd.DataFrame, optional): If provided, pushes metadata directly via SPy.\n        \"\"\"\n        if metadata_df is not None:\n            log_info(\"\ud83d\udce6 [PushManager] Pushing metadata DataFrame directly to Seeq...\")\n            spy.push(metadata=metadata_df)\n            log_info(\"\u2705 Metadata push successful.\")\n            return\n\n        return self.strategy.push(self.tree, metadata_state_file)\n</code></pre>"},{"location":"#itv_asset_tree.core.push_manager.PushManager.__init__","title":"<code>__init__(tree, strategy=None)</code>","text":"<p>Initializes the PushManager with an asset tree and a push strategy.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <p>The asset tree to be pushed.</p> required <code>strategy</code> <code>PushStrategy</code> <p>The strategy to use for pushing the tree. Defaults to <code>ImmediatePush</code> if no strategy is provided.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided tree is empty or invalid.</p> Source code in <code>itv_asset_tree/core/push_manager.py</code> <pre><code>def __init__(self, tree, strategy: PushStrategy = None):\n    \"\"\"\n    Initializes the PushManager with an asset tree and a push strategy.\n\n    Args:\n        tree: The asset tree to be pushed.\n        strategy (PushStrategy, optional): The strategy to use for pushing the tree.\n            Defaults to `ImmediatePush` if no strategy is provided.\n\n    Raises:\n        ValueError: If the provided tree is empty or invalid.\n    \"\"\"\n    if not tree:\n        raise ValueError(\"\u274c PushManager received an empty tree.\")\n\n    log_debug(f\"\u2705 [DEBUG] PushManager initialized with tree '{tree.name}'.\")\n\n    self.tree = tree\n    self.strategy = strategy if strategy else ImmediatePush()  # Default strategy\n</code></pre>"},{"location":"#itv_asset_tree.core.push_manager.PushManager.push","title":"<code>push(metadata_state_file=None, metadata_df=None)</code>","text":"<p>Executes the push operation using the assigned push strategy, or pushes metadata directly.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_state_file</code> <code>str</code> <p>Path to metadata state file.</p> <code>None</code> <code>metadata_df</code> <code>DataFrame</code> <p>If provided, pushes metadata directly via SPy.</p> <code>None</code> Source code in <code>itv_asset_tree/core/push_manager.py</code> <pre><code>def push(self, metadata_state_file=None, metadata_df=None):\n    \"\"\"\n    Executes the push operation using the assigned push strategy, or pushes metadata directly.\n\n    Args:\n        metadata_state_file (str, optional): Path to metadata state file.\n        metadata_df (pd.DataFrame, optional): If provided, pushes metadata directly via SPy.\n    \"\"\"\n    if metadata_df is not None:\n        log_info(\"\ud83d\udce6 [PushManager] Pushing metadata DataFrame directly to Seeq...\")\n        spy.push(metadata=metadata_df)\n        log_info(\"\u2705 Metadata push successful.\")\n        return\n\n    return self.strategy.push(self.tree, metadata_state_file)\n</code></pre>"},{"location":"#itv_asset_tree.core.push_strategies.BatchPush","title":"<code>BatchPush</code>","text":"<p>               Bases: <code>PushStrategy</code></p> <p>Batches multiple tree changes before committing them to Seeq.</p> Source code in <code>itv_asset_tree/core/push_strategies.py</code> <pre><code>class BatchPush(PushStrategy):\n    \"\"\"\n    Batches multiple tree changes before committing them to Seeq.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes a batch queue for storing asset trees to be pushed later.\n        \"\"\"\n        self.batch = []\n\n    def push(self, tree, metadata_state_file=None):\n        \"\"\"\n        Adds an asset tree to the batch queue.\n\n        Args:\n            tree: The asset tree to be added to the batch.\n            metadata_state_file (str, optional): The path to the metadata state file.\n\n        Raises:\n            ValueError: If the tree is not available.\n        \"\"\"\n        if not tree:\n            raise ValueError(\"\u274c No tree available to push.\")\n\n        log_debug(f\"\ud83d\udee0 [DEBUG] Adding tree '{tree.name}' to batch queue.\")\n        self.batch.append((tree, metadata_state_file))\n\n    def commit(self):\n        \"\"\"\n        Pushes all batched asset trees to Seeq at once.\n        \"\"\"\n        if not self.batch:\n            log_debug(\"\u26a0\ufe0f [DEBUG] No trees in batch. Nothing to push.\")\n            return\n\n        for tree, metadata_state_file in self.batch:\n            log_debug(f\"\ud83d\ude80 [DEBUG] Batch pushing tree '{tree.name}'...\")\n            tree.push(metadata_state_file=metadata_state_file)\n\n        self.batch.clear()\n        log_debug(\"\u2705 [DEBUG] All batched trees pushed successfully.\")\n\n    def clear_batch(self):\n        \"\"\"\n        Clears the batch queue, discarding all pending changes.\n        \"\"\"\n        log_debug(\"\u26a0\ufe0f [DEBUG] Clearing batch queue. All changes discarded.\")\n        self.batch.clear()\n</code></pre>"},{"location":"#itv_asset_tree.core.push_strategies.BatchPush.__init__","title":"<code>__init__()</code>","text":"<p>Initializes a batch queue for storing asset trees to be pushed later.</p> Source code in <code>itv_asset_tree/core/push_strategies.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes a batch queue for storing asset trees to be pushed later.\n    \"\"\"\n    self.batch = []\n</code></pre>"},{"location":"#itv_asset_tree.core.push_strategies.BatchPush.clear_batch","title":"<code>clear_batch()</code>","text":"<p>Clears the batch queue, discarding all pending changes.</p> Source code in <code>itv_asset_tree/core/push_strategies.py</code> <pre><code>def clear_batch(self):\n    \"\"\"\n    Clears the batch queue, discarding all pending changes.\n    \"\"\"\n    log_debug(\"\u26a0\ufe0f [DEBUG] Clearing batch queue. All changes discarded.\")\n    self.batch.clear()\n</code></pre>"},{"location":"#itv_asset_tree.core.push_strategies.BatchPush.commit","title":"<code>commit()</code>","text":"<p>Pushes all batched asset trees to Seeq at once.</p> Source code in <code>itv_asset_tree/core/push_strategies.py</code> <pre><code>def commit(self):\n    \"\"\"\n    Pushes all batched asset trees to Seeq at once.\n    \"\"\"\n    if not self.batch:\n        log_debug(\"\u26a0\ufe0f [DEBUG] No trees in batch. Nothing to push.\")\n        return\n\n    for tree, metadata_state_file in self.batch:\n        log_debug(f\"\ud83d\ude80 [DEBUG] Batch pushing tree '{tree.name}'...\")\n        tree.push(metadata_state_file=metadata_state_file)\n\n    self.batch.clear()\n    log_debug(\"\u2705 [DEBUG] All batched trees pushed successfully.\")\n</code></pre>"},{"location":"#itv_asset_tree.core.push_strategies.BatchPush.push","title":"<code>push(tree, metadata_state_file=None)</code>","text":"<p>Adds an asset tree to the batch queue.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <p>The asset tree to be added to the batch.</p> required <code>metadata_state_file</code> <code>str</code> <p>The path to the metadata state file.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tree is not available.</p> Source code in <code>itv_asset_tree/core/push_strategies.py</code> <pre><code>def push(self, tree, metadata_state_file=None):\n    \"\"\"\n    Adds an asset tree to the batch queue.\n\n    Args:\n        tree: The asset tree to be added to the batch.\n        metadata_state_file (str, optional): The path to the metadata state file.\n\n    Raises:\n        ValueError: If the tree is not available.\n    \"\"\"\n    if not tree:\n        raise ValueError(\"\u274c No tree available to push.\")\n\n    log_debug(f\"\ud83d\udee0 [DEBUG] Adding tree '{tree.name}' to batch queue.\")\n    self.batch.append((tree, metadata_state_file))\n</code></pre>"},{"location":"#itv_asset_tree.core.push_strategies.DryRunPush","title":"<code>DryRunPush</code>","text":"<p>               Bases: <code>PushStrategy</code></p> <p>Simulates a push operation without actually modifying Seeq.</p> Source code in <code>itv_asset_tree/core/push_strategies.py</code> <pre><code>class DryRunPush(PushStrategy):\n    \"\"\"\n    Simulates a push operation without actually modifying Seeq.\n    \"\"\"\n\n    def push(self, tree, metadata_state_file=None):\n        \"\"\"\n        Performs a dry-run push for testing purposes.\n\n        Args:\n            tree: The asset tree being simulated.\n            metadata_state_file (str, optional): The path to the metadata state file.\n\n        Returns:\n            dict: Details of the simulated push operation.\n        \"\"\"\n        log_debug(f\"\ud83d\udcdd [DEBUG] Dry-run push for tree '{tree.name}'. No changes applied.\")\n        return {\n            \"message\": f\"Dry-run push for tree '{tree.name}' completed.\",\n            \"tree_name\": tree.name,\n            \"metadata_file\": metadata_state_file or \"N/A\",\n            \"action\": \"dry_run\"\n        }\n</code></pre>"},{"location":"#itv_asset_tree.core.push_strategies.DryRunPush.push","title":"<code>push(tree, metadata_state_file=None)</code>","text":"<p>Performs a dry-run push for testing purposes.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <p>The asset tree being simulated.</p> required <code>metadata_state_file</code> <code>str</code> <p>The path to the metadata state file.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Details of the simulated push operation.</p> Source code in <code>itv_asset_tree/core/push_strategies.py</code> <pre><code>def push(self, tree, metadata_state_file=None):\n    \"\"\"\n    Performs a dry-run push for testing purposes.\n\n    Args:\n        tree: The asset tree being simulated.\n        metadata_state_file (str, optional): The path to the metadata state file.\n\n    Returns:\n        dict: Details of the simulated push operation.\n    \"\"\"\n    log_debug(f\"\ud83d\udcdd [DEBUG] Dry-run push for tree '{tree.name}'. No changes applied.\")\n    return {\n        \"message\": f\"Dry-run push for tree '{tree.name}' completed.\",\n        \"tree_name\": tree.name,\n        \"metadata_file\": metadata_state_file or \"N/A\",\n        \"action\": \"dry_run\"\n    }\n</code></pre>"},{"location":"#itv_asset_tree.core.push_strategies.ImmediatePush","title":"<code>ImmediatePush</code>","text":"<p>               Bases: <code>PushStrategy</code></p> <p>Pushes changes to Seeq immediately after every modification.</p> Source code in <code>itv_asset_tree/core/push_strategies.py</code> <pre><code>class ImmediatePush(PushStrategy):\n    \"\"\"\n    Pushes changes to Seeq immediately after every modification.\n    \"\"\"\n\n    def push(self, tree, metadata_state_file=None):\n        \"\"\"\n        Executes an immediate push operation for the given asset tree.\n\n        Args:\n            tree: The asset tree to be pushed.\n            metadata_state_file (str, optional): The path to the metadata state file.\n\n        Returns:\n            dict: A message indicating the success or failure of the push operation.\n\n        Raises:\n            ValueError: If the tree is not available for pushing.\n        \"\"\"\n        if not tree:\n            raise ValueError(\"\u274c No tree available to push.\")\n\n        log_debug(f\"\ud83d\ude80 [DEBUG] Pushing tree '{tree.name}' to Seeq immediately...\")\n\n        try:\n            tree.push(metadata_state_file=metadata_state_file)\n            log_info(f\"\u2705 Tree '{tree.name}' successfully pushed.\")\n            return {\"message\": f\"Tree '{tree.name}' pushed successfully.\"}\n        except Exception as e:\n            log_error(f\"\u274c [ERROR] Push failed: {e}\")\n            return {\"error\": str(e)}\n</code></pre>"},{"location":"#itv_asset_tree.core.push_strategies.ImmediatePush.push","title":"<code>push(tree, metadata_state_file=None)</code>","text":"<p>Executes an immediate push operation for the given asset tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <p>The asset tree to be pushed.</p> required <code>metadata_state_file</code> <code>str</code> <p>The path to the metadata state file.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A message indicating the success or failure of the push operation.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tree is not available for pushing.</p> Source code in <code>itv_asset_tree/core/push_strategies.py</code> <pre><code>def push(self, tree, metadata_state_file=None):\n    \"\"\"\n    Executes an immediate push operation for the given asset tree.\n\n    Args:\n        tree: The asset tree to be pushed.\n        metadata_state_file (str, optional): The path to the metadata state file.\n\n    Returns:\n        dict: A message indicating the success or failure of the push operation.\n\n    Raises:\n        ValueError: If the tree is not available for pushing.\n    \"\"\"\n    if not tree:\n        raise ValueError(\"\u274c No tree available to push.\")\n\n    log_debug(f\"\ud83d\ude80 [DEBUG] Pushing tree '{tree.name}' to Seeq immediately...\")\n\n    try:\n        tree.push(metadata_state_file=metadata_state_file)\n        log_info(f\"\u2705 Tree '{tree.name}' successfully pushed.\")\n        return {\"message\": f\"Tree '{tree.name}' pushed successfully.\"}\n    except Exception as e:\n        log_error(f\"\u274c [ERROR] Push failed: {e}\")\n        return {\"error\": str(e)}\n</code></pre>"},{"location":"#itv_asset_tree.core.push_strategies.PushStrategy","title":"<code>PushStrategy</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class defining the interface for different push strategies.</p> <p>Subclasses must implement the <code>push</code> method to define how asset trees should be pushed to Seeq.</p> Source code in <code>itv_asset_tree/core/push_strategies.py</code> <pre><code>class PushStrategy(ABC):\n    \"\"\"\n    Abstract base class defining the interface for different push strategies.\n\n    Subclasses must implement the `push` method to define how asset trees\n    should be pushed to Seeq.\n    \"\"\"\n\n    @abstractmethod\n    def push(self, tree, metadata_state_file=None):\n        \"\"\"\n        Pushes the asset tree to Seeq.\n\n        Args:\n            tree: The asset tree to be pushed.\n            metadata_state_file (str, optional): The path to the metadata state file.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"#itv_asset_tree.core.push_strategies.PushStrategy.push","title":"<code>push(tree, metadata_state_file=None)</code>  <code>abstractmethod</code>","text":"<p>Pushes the asset tree to Seeq.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <p>The asset tree to be pushed.</p> required <code>metadata_state_file</code> <code>str</code> <p>The path to the metadata state file.</p> <code>None</code> Source code in <code>itv_asset_tree/core/push_strategies.py</code> <pre><code>@abstractmethod\ndef push(self, tree, metadata_state_file=None):\n    \"\"\"\n    Pushes the asset tree to Seeq.\n\n    Args:\n        tree: The asset tree to be pushed.\n        metadata_state_file (str, optional): The path to the metadata state file.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#itv_asset_tree.core.seeq_adapter.SeeqAdapter","title":"<code>SeeqAdapter</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract Adapter Interface for interacting with Seeq.</p> <p>This class defines the interface for interacting with Seeq, including searching, pushing metadata, and authentication.</p> Source code in <code>itv_asset_tree/core/seeq_adapter.py</code> <pre><code>class SeeqAdapter(ABC):\n    \"\"\"\n    Abstract Adapter Interface for interacting with Seeq.\n\n    This class defines the interface for interacting with Seeq, including searching,\n    pushing metadata, and authentication.\n    \"\"\"\n\n    @abstractmethod\n    def search(self, search_query: str, search_type: str, datasource_name: str) -&gt; pd.DataFrame:\n        \"\"\"\n        Searches for items in Seeq.\n\n        Args:\n            search_query (str): The search query string.\n            search_type (str): The type of search (e.g., \"StoredSignal\").\n            datasource_name (str): The name of the datasource to search within.\n\n        Returns:\n            pd.DataFrame: A DataFrame containing the search results.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def push(self, metadata: pd.DataFrame, workbook: str) -&gt; None:\n        \"\"\"\n        Pushes metadata to Seeq.\n\n        Args:\n            metadata (pd.DataFrame): The metadata to push.\n            workbook (str): The name of the workbook to push the metadata into.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def login(self, url: str, username: str, password: str) -&gt; None:\n        \"\"\"\n        Authenticates with Seeq.\n\n        Args:\n            url (str): The Seeq server URL.\n            username (str): The username for authentication.\n            password (str): The password for authentication.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"#itv_asset_tree.core.seeq_adapter.SeeqAdapter.login","title":"<code>login(url, username, password)</code>  <code>abstractmethod</code>","text":"<p>Authenticates with Seeq.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The Seeq server URL.</p> required <code>username</code> <code>str</code> <p>The username for authentication.</p> required <code>password</code> <code>str</code> <p>The password for authentication.</p> required Source code in <code>itv_asset_tree/core/seeq_adapter.py</code> <pre><code>@abstractmethod\ndef login(self, url: str, username: str, password: str) -&gt; None:\n    \"\"\"\n    Authenticates with Seeq.\n\n    Args:\n        url (str): The Seeq server URL.\n        username (str): The username for authentication.\n        password (str): The password for authentication.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#itv_asset_tree.core.seeq_adapter.SeeqAdapter.push","title":"<code>push(metadata, workbook)</code>  <code>abstractmethod</code>","text":"<p>Pushes metadata to Seeq.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>DataFrame</code> <p>The metadata to push.</p> required <code>workbook</code> <code>str</code> <p>The name of the workbook to push the metadata into.</p> required Source code in <code>itv_asset_tree/core/seeq_adapter.py</code> <pre><code>@abstractmethod\ndef push(self, metadata: pd.DataFrame, workbook: str) -&gt; None:\n    \"\"\"\n    Pushes metadata to Seeq.\n\n    Args:\n        metadata (pd.DataFrame): The metadata to push.\n        workbook (str): The name of the workbook to push the metadata into.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#itv_asset_tree.core.seeq_adapter.SeeqAdapter.search","title":"<code>search(search_query, search_type, datasource_name)</code>  <code>abstractmethod</code>","text":"<p>Searches for items in Seeq.</p> <p>Parameters:</p> Name Type Description Default <code>search_query</code> <code>str</code> <p>The search query string.</p> required <code>search_type</code> <code>str</code> <p>The type of search (e.g., \"StoredSignal\").</p> required <code>datasource_name</code> <code>str</code> <p>The name of the datasource to search within.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing the search results.</p> Source code in <code>itv_asset_tree/core/seeq_adapter.py</code> <pre><code>@abstractmethod\ndef search(self, search_query: str, search_type: str, datasource_name: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Searches for items in Seeq.\n\n    Args:\n        search_query (str): The search query string.\n        search_type (str): The type of search (e.g., \"StoredSignal\").\n        datasource_name (str): The name of the datasource to search within.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the search results.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#itv_asset_tree.core.seeq_adapter.SeeqSpyAdapter","title":"<code>SeeqSpyAdapter</code>","text":"<p>               Bases: <code>SeeqAdapter</code></p> <p>Concrete Adapter for Seeq, using spy.</p> <p>This class implements the SeeqAdapter interface using the Seeq <code>spy</code> library.</p> Source code in <code>itv_asset_tree/core/seeq_adapter.py</code> <pre><code>class SeeqSpyAdapter(SeeqAdapter):\n    \"\"\"\n    Concrete Adapter for Seeq, using spy.\n\n    This class implements the SeeqAdapter interface using the Seeq `spy` library.\n    \"\"\"\n\n    @staticmethod\n    def search(search_query: str, search_type: str, datasource_name: str):\n        \"\"\"\n        Searches for signals or assets in Seeq.\n\n        Args:\n            search_query (str): The search query string.\n            search_type (str): The type of search (e.g., \"StoredSignal\").\n            datasource_name (str): The name of the datasource to search within.\n\n        Returns:\n            pd.DataFrame: A DataFrame containing the search results.\n        \"\"\"\n        try:\n            query_payload = {\n                \"Name\": search_query,\n                \"Type\": search_type,\n                \"Datasource Name\": datasource_name\n            }\n\n            log_info(f\"\ud83d\udd0d Performing Seeq search: {query_payload}\")\n            search_results = spy.search(query_payload)\n\n            if search_results.empty:\n                log_warning(\"\u26a0\ufe0f No results found in Seeq search.\")\n                return pd.DataFrame()\n\n            return search_results\n\n        except Exception as e:\n            log_error(f\"\u274c Error searching Seeq: {e}\")\n            return pd.DataFrame()\n\n    @staticmethod\n    def search_signals(search_query: str):\n        \"\"\"\n        Fetches stored signals from Seeq, sorts them alphabetically, and returns them.\n\n        Args:\n            search_query (str): The search query string.\n\n        Returns:\n            list: A sorted list of signal names found in Seeq.\n        \"\"\"\n        log_info(f\"\ud83d\udd0d Fetching stored signals for query: {search_query}\")\n\n        search_results = SeeqSpyAdapter.search(search_query, \"StoredSignal\")\n\n        if search_results.empty:\n            log_warning(\"\u26a0\ufe0f No stored signals found in Seeq search.\")\n            return []\n\n        # Sort signal names alphabetically before returning\n        sorted_signals = sorted(search_results[\"Name\"].tolist())\n\n        log_info(f\"\u2705 Retrieved {len(sorted_signals)} signals (sorted).\")\n        return sorted_signals\n\n    @staticmethod\n    def search_in_tree(search_query: str, tree_path: str) -&gt; pd.DataFrame:\n        \"\"\"\n        Searches for signals within an asset tree in Seeq based on a path.\n\n        Args:\n            search_query (str): The name or pattern to search for.\n            tree_path (str): The full path to the asset tree, in the form \"Workbook &gt;&gt; Tree\".\n\n        Returns:\n            pd.DataFrame: Filtered DataFrame of matching signals from the tree.\n\n        Raises:\n            ValueError: If the provided tree path is not valid.\n        \"\"\"\n        split_path = [p.strip() for p in tree_path.split(\"&gt;&gt;\")]\n        if len(split_path) &lt; 2:\n            raise ValueError(\"Invalid asset tree path. Must be: 'Workbook &gt;&gt; Tree'\")\n\n        workbook_name = \" &gt;&gt; \".join(split_path[:-1])\n        tree_name = split_path[-1]\n\n        tree = Tree(tree_name, workbook=workbook_name)\n        tree_df = tree.df\n\n        signal_df = tree_df[tree_df[\"Type\"].isin([\"Signal\", \"StoredSignal\", \"CalculatedSignal\"])]\n        filtered = signal_df[signal_df[\"Name\"].str.contains(search_query.replace(\"*\", \".*\"), regex=True, case=False)]\n\n        return filtered\n\n    @staticmethod\n    def build_and_push(model_class, metadata_df: pd.DataFrame, workbook_name: str):\n        \"\"\"\n        Builds assets using the provided template and pushes them to Seeq.\n\n        Args:\n            model_class: The asset model class to be used for building.\n            metadata_df (pd.DataFrame): The metadata DataFrame containing asset details.\n            workbook_name (str): The name of the workbook to push the built assets into.\n\n        Returns:\n            dict: A message indicating success or failure.\n\n        Raises:\n            ValueError: If the provided model class is invalid or the build process fails.\n        \"\"\"\n        try:\n            log_info(f\"\ud83d\udd28 Building asset tree using template: {model_class.__name__}\")\n\n            if not callable(model_class):\n                raise ValueError(f\"\u274c Invalid template class provided: {model_class}\")\n\n            build_df = spy.assets.build(model_class, metadata_df)\n\n            if build_df.empty:\n                raise ValueError(\"\ud83d\udea8 Build process returned an empty DataFrame. No assets were created.\")\n\n            spy.push(metadata=build_df, workbook=workbook_name)\n            log_info(f\"\u2705 Successfully pushed assets to Seeq workbook: {workbook_name}\")\n\n            return {\"message\": \"\u2705 Successfully built and pushed asset tree.\"}\n\n        except Exception as e:\n            log_error(f\"\u274c Error in build_and_push: {e}\")\n            raise ValueError(f\"\u274c Failed to build and push assets: {e}\")\n\n    def push(self, metadata: pd.DataFrame, workbook: str) -&gt; None:\n        \"\"\"\n        Pushes metadata to Seeq.\n\n        Args:\n            metadata (pd.DataFrame): The metadata DataFrame to be pushed.\n            workbook (str): The name of the workbook where metadata will be pushed.\n        \"\"\"\n        try:\n            spy.push(metadata=metadata, workbook=workbook)\n            log_debug(f\"\u2705 [DEBUG] Data pushed successfully to workbook: {workbook}\")\n        except Exception as e:\n            log_debug(f\"\u274c [ERROR] Failed to push to Seeq: {e}\")\n\n    def login(self, url: str, username: str, password: str) -&gt; None:\n        \"\"\"\n        Logs into Seeq.\n\n        Args:\n            url (str): The Seeq server URL.\n            username (str): The username for authentication.\n            password (str): The password for authentication.\n        \"\"\"\n        try:\n            spy.login(url=url, username=username, password=password)\n            log_debug(f\"\u2705 [DEBUG] Successfully logged into Seeq at {url}\")\n        except Exception as e:\n            log_debug(f\"\u274c [ERROR] Seeq login failed: {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.seeq_adapter.SeeqSpyAdapter.build_and_push","title":"<code>build_and_push(model_class, metadata_df, workbook_name)</code>  <code>staticmethod</code>","text":"<p>Builds assets using the provided template and pushes them to Seeq.</p> <p>Parameters:</p> Name Type Description Default <code>model_class</code> <p>The asset model class to be used for building.</p> required <code>metadata_df</code> <code>DataFrame</code> <p>The metadata DataFrame containing asset details.</p> required <code>workbook_name</code> <code>str</code> <p>The name of the workbook to push the built assets into.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A message indicating success or failure.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided model class is invalid or the build process fails.</p> Source code in <code>itv_asset_tree/core/seeq_adapter.py</code> <pre><code>@staticmethod\ndef build_and_push(model_class, metadata_df: pd.DataFrame, workbook_name: str):\n    \"\"\"\n    Builds assets using the provided template and pushes them to Seeq.\n\n    Args:\n        model_class: The asset model class to be used for building.\n        metadata_df (pd.DataFrame): The metadata DataFrame containing asset details.\n        workbook_name (str): The name of the workbook to push the built assets into.\n\n    Returns:\n        dict: A message indicating success or failure.\n\n    Raises:\n        ValueError: If the provided model class is invalid or the build process fails.\n    \"\"\"\n    try:\n        log_info(f\"\ud83d\udd28 Building asset tree using template: {model_class.__name__}\")\n\n        if not callable(model_class):\n            raise ValueError(f\"\u274c Invalid template class provided: {model_class}\")\n\n        build_df = spy.assets.build(model_class, metadata_df)\n\n        if build_df.empty:\n            raise ValueError(\"\ud83d\udea8 Build process returned an empty DataFrame. No assets were created.\")\n\n        spy.push(metadata=build_df, workbook=workbook_name)\n        log_info(f\"\u2705 Successfully pushed assets to Seeq workbook: {workbook_name}\")\n\n        return {\"message\": \"\u2705 Successfully built and pushed asset tree.\"}\n\n    except Exception as e:\n        log_error(f\"\u274c Error in build_and_push: {e}\")\n        raise ValueError(f\"\u274c Failed to build and push assets: {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.seeq_adapter.SeeqSpyAdapter.login","title":"<code>login(url, username, password)</code>","text":"<p>Logs into Seeq.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The Seeq server URL.</p> required <code>username</code> <code>str</code> <p>The username for authentication.</p> required <code>password</code> <code>str</code> <p>The password for authentication.</p> required Source code in <code>itv_asset_tree/core/seeq_adapter.py</code> <pre><code>def login(self, url: str, username: str, password: str) -&gt; None:\n    \"\"\"\n    Logs into Seeq.\n\n    Args:\n        url (str): The Seeq server URL.\n        username (str): The username for authentication.\n        password (str): The password for authentication.\n    \"\"\"\n    try:\n        spy.login(url=url, username=username, password=password)\n        log_debug(f\"\u2705 [DEBUG] Successfully logged into Seeq at {url}\")\n    except Exception as e:\n        log_debug(f\"\u274c [ERROR] Seeq login failed: {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.seeq_adapter.SeeqSpyAdapter.push","title":"<code>push(metadata, workbook)</code>","text":"<p>Pushes metadata to Seeq.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>DataFrame</code> <p>The metadata DataFrame to be pushed.</p> required <code>workbook</code> <code>str</code> <p>The name of the workbook where metadata will be pushed.</p> required Source code in <code>itv_asset_tree/core/seeq_adapter.py</code> <pre><code>def push(self, metadata: pd.DataFrame, workbook: str) -&gt; None:\n    \"\"\"\n    Pushes metadata to Seeq.\n\n    Args:\n        metadata (pd.DataFrame): The metadata DataFrame to be pushed.\n        workbook (str): The name of the workbook where metadata will be pushed.\n    \"\"\"\n    try:\n        spy.push(metadata=metadata, workbook=workbook)\n        log_debug(f\"\u2705 [DEBUG] Data pushed successfully to workbook: {workbook}\")\n    except Exception as e:\n        log_debug(f\"\u274c [ERROR] Failed to push to Seeq: {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.seeq_adapter.SeeqSpyAdapter.search","title":"<code>search(search_query, search_type, datasource_name)</code>  <code>staticmethod</code>","text":"<p>Searches for signals or assets in Seeq.</p> <p>Parameters:</p> Name Type Description Default <code>search_query</code> <code>str</code> <p>The search query string.</p> required <code>search_type</code> <code>str</code> <p>The type of search (e.g., \"StoredSignal\").</p> required <code>datasource_name</code> <code>str</code> <p>The name of the datasource to search within.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: A DataFrame containing the search results.</p> Source code in <code>itv_asset_tree/core/seeq_adapter.py</code> <pre><code>@staticmethod\ndef search(search_query: str, search_type: str, datasource_name: str):\n    \"\"\"\n    Searches for signals or assets in Seeq.\n\n    Args:\n        search_query (str): The search query string.\n        search_type (str): The type of search (e.g., \"StoredSignal\").\n        datasource_name (str): The name of the datasource to search within.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the search results.\n    \"\"\"\n    try:\n        query_payload = {\n            \"Name\": search_query,\n            \"Type\": search_type,\n            \"Datasource Name\": datasource_name\n        }\n\n        log_info(f\"\ud83d\udd0d Performing Seeq search: {query_payload}\")\n        search_results = spy.search(query_payload)\n\n        if search_results.empty:\n            log_warning(\"\u26a0\ufe0f No results found in Seeq search.\")\n            return pd.DataFrame()\n\n        return search_results\n\n    except Exception as e:\n        log_error(f\"\u274c Error searching Seeq: {e}\")\n        return pd.DataFrame()\n</code></pre>"},{"location":"#itv_asset_tree.core.seeq_adapter.SeeqSpyAdapter.search_in_tree","title":"<code>search_in_tree(search_query, tree_path)</code>  <code>staticmethod</code>","text":"<p>Searches for signals within an asset tree in Seeq based on a path.</p> <p>Parameters:</p> Name Type Description Default <code>search_query</code> <code>str</code> <p>The name or pattern to search for.</p> required <code>tree_path</code> <code>str</code> <p>The full path to the asset tree, in the form \"Workbook &gt;&gt; Tree\".</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Filtered DataFrame of matching signals from the tree.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided tree path is not valid.</p> Source code in <code>itv_asset_tree/core/seeq_adapter.py</code> <pre><code>@staticmethod\ndef search_in_tree(search_query: str, tree_path: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Searches for signals within an asset tree in Seeq based on a path.\n\n    Args:\n        search_query (str): The name or pattern to search for.\n        tree_path (str): The full path to the asset tree, in the form \"Workbook &gt;&gt; Tree\".\n\n    Returns:\n        pd.DataFrame: Filtered DataFrame of matching signals from the tree.\n\n    Raises:\n        ValueError: If the provided tree path is not valid.\n    \"\"\"\n    split_path = [p.strip() for p in tree_path.split(\"&gt;&gt;\")]\n    if len(split_path) &lt; 2:\n        raise ValueError(\"Invalid asset tree path. Must be: 'Workbook &gt;&gt; Tree'\")\n\n    workbook_name = \" &gt;&gt; \".join(split_path[:-1])\n    tree_name = split_path[-1]\n\n    tree = Tree(tree_name, workbook=workbook_name)\n    tree_df = tree.df\n\n    signal_df = tree_df[tree_df[\"Type\"].isin([\"Signal\", \"StoredSignal\", \"CalculatedSignal\"])]\n    filtered = signal_df[signal_df[\"Name\"].str.contains(search_query.replace(\"*\", \".*\"), regex=True, case=False)]\n\n    return filtered\n</code></pre>"},{"location":"#itv_asset_tree.core.seeq_adapter.SeeqSpyAdapter.search_signals","title":"<code>search_signals(search_query)</code>  <code>staticmethod</code>","text":"<p>Fetches stored signals from Seeq, sorts them alphabetically, and returns them.</p> <p>Parameters:</p> Name Type Description Default <code>search_query</code> <code>str</code> <p>The search query string.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A sorted list of signal names found in Seeq.</p> Source code in <code>itv_asset_tree/core/seeq_adapter.py</code> <pre><code>@staticmethod\ndef search_signals(search_query: str):\n    \"\"\"\n    Fetches stored signals from Seeq, sorts them alphabetically, and returns them.\n\n    Args:\n        search_query (str): The search query string.\n\n    Returns:\n        list: A sorted list of signal names found in Seeq.\n    \"\"\"\n    log_info(f\"\ud83d\udd0d Fetching stored signals for query: {search_query}\")\n\n    search_results = SeeqSpyAdapter.search(search_query, \"StoredSignal\")\n\n    if search_results.empty:\n        log_warning(\"\u26a0\ufe0f No stored signals found in Seeq search.\")\n        return []\n\n    # Sort signal names alphabetically before returning\n    sorted_signals = sorted(search_results[\"Name\"].tolist())\n\n    log_info(f\"\u2705 Retrieved {len(sorted_signals)} signals (sorted).\")\n    return sorted_signals\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_archiver.TreeArchiver","title":"<code>TreeArchiver</code>","text":"<p>               Bases: <code>ITreeArchive</code></p> <p>Utility class to archive all items in a Seeq asset tree.</p> <p>This is the only safe and SPy-supported way to 'remove' an asset tree, since Seeq does not support root asset deletion directly via API.</p> Source code in <code>itv_asset_tree/core/tree_archiver.py</code> <pre><code>class TreeArchiver(ITreeArchive):\n    \"\"\"\n    Utility class to archive all items in a Seeq asset tree.\n\n    This is the only safe and SPy-supported way to 'remove' an asset tree,\n    since Seeq does not support root asset deletion directly via API.\n    \"\"\"\n\n    def __init__(self, tree_name: str, workbook: str):\n        \"\"\"\n        Initializes the TreeArchiver with a specific tree and workbook scope.\n\n        Args:\n            tree_name (str): The name of the tree to archive.\n            workbook (str): The name of the workbook containing the tree.\n        \"\"\"\n        self.tree_name = tree_name\n        self.workbook = workbook\n\n        # \ud83d\udc47 Load the actual Tree object\n        self.tree = Tree(tree_name, workbook=workbook)\n        self.push_manager = PushManager(self.tree)  # Correct usage here\n\n    def archive(self):\n        \"\"\"\n        Archives the full asset tree by marking all nodes (root + children) as Archived = True.\n\n        Raises:\n            ValueError: If the tree root cannot be found or no items are discovered under it.\n        \"\"\"\n        try:\n            log_info(f\"\ud83d\udd0d [Archiver] Locating tree '{self.tree_name}' in workbook '{self.workbook}'...\")\n\n            root_result = spy.search(\n                {\"Name\": self.tree_name, \"Type\": \"Asset\"},\n                workbook=spy.GLOBALS_AND_ALL_WORKBOOKS,\n                old_asset_format=False\n            )\n\n            if root_result.empty:\n                raise ValueError(f\"\u274c Root asset '{self.tree_name}' not found.\")\n\n            root_id = root_result.iloc[0][\"ID\"]\n            log_info(f\"\ud83d\udcdb Found root asset ID: {root_id}\")\n\n            items_in_tree = spy.search(\n                [{\"Asset\": root_id}, {\"ID\": root_id}],\n                workbook=spy.GLOBALS_AND_ALL_WORKBOOKS,\n                all_properties=True\n            )\n\n            if items_in_tree.empty:\n                log_warning(f\"\u26a0\ufe0f No items found to archive under '{self.tree_name}'.\")\n                return\n\n            items_in_tree[\"Archived\"] = True\n\n            log_info(f\"\ud83d\udce6 Pushing archive update for {len(items_in_tree)} items...\")\n            spy.push(metadata=items_in_tree)\n            log_info(f\"\u2705 Archived {len(items_in_tree)} items for tree '{self.tree_name}'\")\n\n        except Exception as e:\n            log_error(f\"\u274c Archiving failed: {e}\")\n            raise ValueError(f\"\u274c Archive operation failed: {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_archiver.TreeArchiver.__init__","title":"<code>__init__(tree_name, workbook)</code>","text":"<p>Initializes the TreeArchiver with a specific tree and workbook scope.</p> <p>Parameters:</p> Name Type Description Default <code>tree_name</code> <code>str</code> <p>The name of the tree to archive.</p> required <code>workbook</code> <code>str</code> <p>The name of the workbook containing the tree.</p> required Source code in <code>itv_asset_tree/core/tree_archiver.py</code> <pre><code>def __init__(self, tree_name: str, workbook: str):\n    \"\"\"\n    Initializes the TreeArchiver with a specific tree and workbook scope.\n\n    Args:\n        tree_name (str): The name of the tree to archive.\n        workbook (str): The name of the workbook containing the tree.\n    \"\"\"\n    self.tree_name = tree_name\n    self.workbook = workbook\n\n    # \ud83d\udc47 Load the actual Tree object\n    self.tree = Tree(tree_name, workbook=workbook)\n    self.push_manager = PushManager(self.tree)  # Correct usage here\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_archiver.TreeArchiver.archive","title":"<code>archive()</code>","text":"<p>Archives the full asset tree by marking all nodes (root + children) as Archived = True.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tree root cannot be found or no items are discovered under it.</p> Source code in <code>itv_asset_tree/core/tree_archiver.py</code> <pre><code>def archive(self):\n    \"\"\"\n    Archives the full asset tree by marking all nodes (root + children) as Archived = True.\n\n    Raises:\n        ValueError: If the tree root cannot be found or no items are discovered under it.\n    \"\"\"\n    try:\n        log_info(f\"\ud83d\udd0d [Archiver] Locating tree '{self.tree_name}' in workbook '{self.workbook}'...\")\n\n        root_result = spy.search(\n            {\"Name\": self.tree_name, \"Type\": \"Asset\"},\n            workbook=spy.GLOBALS_AND_ALL_WORKBOOKS,\n            old_asset_format=False\n        )\n\n        if root_result.empty:\n            raise ValueError(f\"\u274c Root asset '{self.tree_name}' not found.\")\n\n        root_id = root_result.iloc[0][\"ID\"]\n        log_info(f\"\ud83d\udcdb Found root asset ID: {root_id}\")\n\n        items_in_tree = spy.search(\n            [{\"Asset\": root_id}, {\"ID\": root_id}],\n            workbook=spy.GLOBALS_AND_ALL_WORKBOOKS,\n            all_properties=True\n        )\n\n        if items_in_tree.empty:\n            log_warning(f\"\u26a0\ufe0f No items found to archive under '{self.tree_name}'.\")\n            return\n\n        items_in_tree[\"Archived\"] = True\n\n        log_info(f\"\ud83d\udce6 Pushing archive update for {len(items_in_tree)} items...\")\n        spy.push(metadata=items_in_tree)\n        log_info(f\"\u2705 Archived {len(items_in_tree)} items for tree '{self.tree_name}'\")\n\n    except Exception as e:\n        log_error(f\"\u274c Archiving failed: {e}\")\n        raise ValueError(f\"\u274c Archive operation failed: {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_builder.TreeBuilder","title":"<code>TreeBuilder</code>","text":"<p>Class to manage tree creation and manipulation in Seeq.</p> <p>This class provides methods to parse CSV files, build empty or structured trees, visualize the tree structure, and retrieve a push manager for committing changes.</p> Source code in <code>itv_asset_tree/core/tree_builder.py</code> <pre><code>class TreeBuilder:\n    \"\"\"\n    Class to manage tree creation and manipulation in Seeq.\n\n    This class provides methods to parse CSV files, build empty or structured trees,\n    visualize the tree structure, and retrieve a push manager for committing changes.\n    \"\"\"\n\n    def __init__(self, workbook: str, csv_file: Optional[str] = None):\n        \"\"\"\n        Initializes the TreeBuilder with a specified workbook and optional CSV file.\n\n        Args:\n            workbook (str): The name of the workbook where the tree will be created.\n            csv_file (Optional[str]): The path to a CSV file containing tree structure data.\n        \"\"\"\n        self.workbook = workbook\n        self.csv_file = csv_file\n        self.metadata = None\n        self.tree = None\n\n    def parse_csv(self):\n        \"\"\"\n        Parses the CSV file and loads metadata into a DataFrame.\n\n        Raises:\n            ValueError: If no CSV file is provided.\n        \"\"\"\n        if not self.csv_file:\n            raise ValueError(\"CSV file not provided.\")\n        self.metadata = pd.read_csv(self.csv_file)\n        log_info(f\"\u2705 CSV parsed successfully: {self.csv_file}\")\n\n    def build_empty_tree(self, friendly_name: str, description: str):\n        \"\"\"\n        Builds an empty tree with only the root node.\n\n        Args:\n            friendly_name (str): The display name of the root node.\n            description (str): A description of the tree.\n\n        Returns:\n            Tree: The initialized empty tree instance.\n        \"\"\"\n        root_data = pd.DataFrame([{\n            'Path': '',\n            'Name': friendly_name,\n            'Type': 'Asset',\n            'Formula': None,\n            'Formula Parameters': None,\n            'Datasource ID': None,\n            'Datasource Class': None,\n            'Description': description,\n        }])\n        self.tree = Tree(\n            data=root_data,\n            workbook=self.workbook,\n            friendly_name=friendly_name,\n            description=description,\n        )\n        log_info(f\"\ud83c\udf33 Empty tree '{friendly_name}' created successfully.\")\n        return self.tree\n\n    def build_tree_from_csv(self, friendly_name: str, description: str):\n        \"\"\"\n        Builds a tree from a provided CSV file and initializes it in Seeq.\n\n        Args:\n            friendly_name (str): The display name of the tree.\n            description (str): A description of the tree.\n\n        Raises:\n            ValueError: If no CSV file is provided.\n            RuntimeError: If tree creation fails.\n        \"\"\"\n        if not self.csv_file:\n            raise ValueError(\"CSV file not provided.\")\n\n        try:\n            # Build the tree using Seeq API\n            self.tree = Tree(\n                data=self.csv_file,  # Pass the CSV file path directly\n                workbook=self.workbook,\n                friendly_name=friendly_name,\n                description=description,\n            )\n            log_info(f\"\ud83c\udf33 Tree '{friendly_name}' created successfully.\")\n        except Exception as e:\n            raise RuntimeError(f\"Error creating tree: {e}\")\n\n    def visualize_tree(self):\n        \"\"\"\n        Visualizes the tree structure in a readable format.\n\n        Returns:\n            str or dict: A structured tree visualization or a JSON-like representation if visualization fails.\n\n        Raises:\n            ValueError: If the tree has not been built yet.\n        \"\"\"\n        if not self.tree:\n            raise ValueError(\"Tree not built yet.\")\n\n        try:\n            # Attempt to summarize the tree\n            structure = self.tree.visualize()\n            if not structure:\n                raise ValueError(\"\ud800\udcb7 Tree.summarize() returned an empty structure.\")\n            return structure\n        except Exception as e:\n            log_error(f\"\u274c Tree.summarize() failed: {e}\")\n            # Use the fallback method\n            return self._convert_tree_to_json()\n\n    def _convert_tree_to_json(self):\n        \"\"\"\n        Converts the tree into a JSON-like nested dictionary for visualization.\n\n        Returns:\n            dict: A structured representation of the tree hierarchy.\n        \"\"\"\n        if not self.tree:\n            return {\"error\": \"Tree not built yet.\"}\n\n        from io import StringIO\n        import contextlib\n\n        # Capture the tree visualization as a string\n        with StringIO() as buf, contextlib.redirect_stdout(buf):\n            self.tree.visualize()\n            visualization = buf.getvalue()\n\n        # Build a JSON-like structure from the tree visualization\n        tree_json = {}\n        current_level = [tree_json]\n        lines = visualization.splitlines()\n        for line in lines:\n            # Calculate the indentation level\n            level = (len(line) - len(line.lstrip(\"| \"))) // 2\n            node_name = line.strip(\"| \").strip()\n\n            # Navigate to the correct level\n            while len(current_level) &gt; level + 1:\n                current_level.pop()\n\n            # Add node to the current level\n            current_node = current_level[-1]\n            if node_name:\n                current_node[node_name] = {}\n                current_level.append(current_node[node_name])\n\n        return tree_json\n\n    def get_push_manager(self):\n        \"\"\"\n        Retrieves a PushManager instance for the current tree.\n\n        Returns:\n            PushManager: An instance of PushManager to handle tree pushing.\n\n        Raises:\n            ValueError: If the tree has not been built yet.\n        \"\"\"\n        if not self.tree:\n            raise ValueError(\"\u274c Tree is not built. Call 'build_empty_tree()' first.\")\n        return PushManager(self.tree)\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_builder.TreeBuilder.__init__","title":"<code>__init__(workbook, csv_file=None)</code>","text":"<p>Initializes the TreeBuilder with a specified workbook and optional CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>workbook</code> <code>str</code> <p>The name of the workbook where the tree will be created.</p> required <code>csv_file</code> <code>Optional[str]</code> <p>The path to a CSV file containing tree structure data.</p> <code>None</code> Source code in <code>itv_asset_tree/core/tree_builder.py</code> <pre><code>def __init__(self, workbook: str, csv_file: Optional[str] = None):\n    \"\"\"\n    Initializes the TreeBuilder with a specified workbook and optional CSV file.\n\n    Args:\n        workbook (str): The name of the workbook where the tree will be created.\n        csv_file (Optional[str]): The path to a CSV file containing tree structure data.\n    \"\"\"\n    self.workbook = workbook\n    self.csv_file = csv_file\n    self.metadata = None\n    self.tree = None\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_builder.TreeBuilder.build_empty_tree","title":"<code>build_empty_tree(friendly_name, description)</code>","text":"<p>Builds an empty tree with only the root node.</p> <p>Parameters:</p> Name Type Description Default <code>friendly_name</code> <code>str</code> <p>The display name of the root node.</p> required <code>description</code> <code>str</code> <p>A description of the tree.</p> required <p>Returns:</p> Name Type Description <code>Tree</code> <p>The initialized empty tree instance.</p> Source code in <code>itv_asset_tree/core/tree_builder.py</code> <pre><code>def build_empty_tree(self, friendly_name: str, description: str):\n    \"\"\"\n    Builds an empty tree with only the root node.\n\n    Args:\n        friendly_name (str): The display name of the root node.\n        description (str): A description of the tree.\n\n    Returns:\n        Tree: The initialized empty tree instance.\n    \"\"\"\n    root_data = pd.DataFrame([{\n        'Path': '',\n        'Name': friendly_name,\n        'Type': 'Asset',\n        'Formula': None,\n        'Formula Parameters': None,\n        'Datasource ID': None,\n        'Datasource Class': None,\n        'Description': description,\n    }])\n    self.tree = Tree(\n        data=root_data,\n        workbook=self.workbook,\n        friendly_name=friendly_name,\n        description=description,\n    )\n    log_info(f\"\ud83c\udf33 Empty tree '{friendly_name}' created successfully.\")\n    return self.tree\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_builder.TreeBuilder.build_tree_from_csv","title":"<code>build_tree_from_csv(friendly_name, description)</code>","text":"<p>Builds a tree from a provided CSV file and initializes it in Seeq.</p> <p>Parameters:</p> Name Type Description Default <code>friendly_name</code> <code>str</code> <p>The display name of the tree.</p> required <code>description</code> <code>str</code> <p>A description of the tree.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If no CSV file is provided.</p> <code>RuntimeError</code> <p>If tree creation fails.</p> Source code in <code>itv_asset_tree/core/tree_builder.py</code> <pre><code>def build_tree_from_csv(self, friendly_name: str, description: str):\n    \"\"\"\n    Builds a tree from a provided CSV file and initializes it in Seeq.\n\n    Args:\n        friendly_name (str): The display name of the tree.\n        description (str): A description of the tree.\n\n    Raises:\n        ValueError: If no CSV file is provided.\n        RuntimeError: If tree creation fails.\n    \"\"\"\n    if not self.csv_file:\n        raise ValueError(\"CSV file not provided.\")\n\n    try:\n        # Build the tree using Seeq API\n        self.tree = Tree(\n            data=self.csv_file,  # Pass the CSV file path directly\n            workbook=self.workbook,\n            friendly_name=friendly_name,\n            description=description,\n        )\n        log_info(f\"\ud83c\udf33 Tree '{friendly_name}' created successfully.\")\n    except Exception as e:\n        raise RuntimeError(f\"Error creating tree: {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_builder.TreeBuilder.get_push_manager","title":"<code>get_push_manager()</code>","text":"<p>Retrieves a PushManager instance for the current tree.</p> <p>Returns:</p> Name Type Description <code>PushManager</code> <p>An instance of PushManager to handle tree pushing.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tree has not been built yet.</p> Source code in <code>itv_asset_tree/core/tree_builder.py</code> <pre><code>def get_push_manager(self):\n    \"\"\"\n    Retrieves a PushManager instance for the current tree.\n\n    Returns:\n        PushManager: An instance of PushManager to handle tree pushing.\n\n    Raises:\n        ValueError: If the tree has not been built yet.\n    \"\"\"\n    if not self.tree:\n        raise ValueError(\"\u274c Tree is not built. Call 'build_empty_tree()' first.\")\n    return PushManager(self.tree)\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_builder.TreeBuilder.parse_csv","title":"<code>parse_csv()</code>","text":"<p>Parses the CSV file and loads metadata into a DataFrame.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no CSV file is provided.</p> Source code in <code>itv_asset_tree/core/tree_builder.py</code> <pre><code>def parse_csv(self):\n    \"\"\"\n    Parses the CSV file and loads metadata into a DataFrame.\n\n    Raises:\n        ValueError: If no CSV file is provided.\n    \"\"\"\n    if not self.csv_file:\n        raise ValueError(\"CSV file not provided.\")\n    self.metadata = pd.read_csv(self.csv_file)\n    log_info(f\"\u2705 CSV parsed successfully: {self.csv_file}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_builder.TreeBuilder.visualize_tree","title":"<code>visualize_tree()</code>","text":"<p>Visualizes the tree structure in a readable format.</p> <p>Returns:</p> Type Description <p>str or dict: A structured tree visualization or a JSON-like representation if visualization fails.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tree has not been built yet.</p> Source code in <code>itv_asset_tree/core/tree_builder.py</code> <pre><code>def visualize_tree(self):\n    \"\"\"\n    Visualizes the tree structure in a readable format.\n\n    Returns:\n        str or dict: A structured tree visualization or a JSON-like representation if visualization fails.\n\n    Raises:\n        ValueError: If the tree has not been built yet.\n    \"\"\"\n    if not self.tree:\n        raise ValueError(\"Tree not built yet.\")\n\n    try:\n        # Attempt to summarize the tree\n        structure = self.tree.visualize()\n        if not structure:\n            raise ValueError(\"\ud800\udcb7 Tree.summarize() returned an empty structure.\")\n        return structure\n    except Exception as e:\n        log_error(f\"\u274c Tree.summarize() failed: {e}\")\n        # Use the fallback method\n        return self._convert_tree_to_json()\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_loader.TreeLoader","title":"<code>TreeLoader</code>","text":"<p>Handles loading and reloading trees from Seeq.</p> <p>This class allows fetching an existing tree from Seeq to ensure that the latest changes are reflected.</p> Source code in <code>itv_asset_tree/core/tree_loader.py</code> <pre><code>class TreeLoader:\n    \"\"\"\n    Handles loading and reloading trees from Seeq.\n\n    This class allows fetching an existing tree from Seeq to ensure\n    that the latest changes are reflected.\n    \"\"\"\n\n    def __init__(self, workbook: str, tree_name: str):\n        \"\"\"\n        Initializes the TreeLoader with a specified workbook and tree name.\n\n        Args:\n            workbook (str): The name of the workbook containing the tree.\n            tree_name (str): The name of the tree to be loaded.\n        \"\"\"\n        self.workbook = workbook\n        self.tree_name = tree_name\n        self.tree = None\n\n    def load_tree(self):\n        \"\"\"\n        Forces a full reload of the tree from Seeq to ensure the latest updates are reflected.\n\n        Returns:\n            Tree: The reloaded tree instance.\n\n        Raises:\n            ValueError: If an error occurs while loading the tree.\n        \"\"\"\n        try:\n            log_info(f\"\ud83d\udd04 Reloading tree '{self.tree_name}' from workbook '{self.workbook}'...\")\n            self.tree = None  # Drop the old reference first\n            self.tree = Tree(self.tree_name, workbook=self.workbook)  # Reload from Seeq\n            log_info(f\"\ud83c\udf33 Tree '{self.tree_name}' reloaded successfully!\")\n            return self.tree\n        except Exception as e:\n            raise ValueError(f\"\u274c Error loading tree '{self.tree_name}': {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_loader.TreeLoader.__init__","title":"<code>__init__(workbook, tree_name)</code>","text":"<p>Initializes the TreeLoader with a specified workbook and tree name.</p> <p>Parameters:</p> Name Type Description Default <code>workbook</code> <code>str</code> <p>The name of the workbook containing the tree.</p> required <code>tree_name</code> <code>str</code> <p>The name of the tree to be loaded.</p> required Source code in <code>itv_asset_tree/core/tree_loader.py</code> <pre><code>def __init__(self, workbook: str, tree_name: str):\n    \"\"\"\n    Initializes the TreeLoader with a specified workbook and tree name.\n\n    Args:\n        workbook (str): The name of the workbook containing the tree.\n        tree_name (str): The name of the tree to be loaded.\n    \"\"\"\n    self.workbook = workbook\n    self.tree_name = tree_name\n    self.tree = None\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_loader.TreeLoader.load_tree","title":"<code>load_tree()</code>","text":"<p>Forces a full reload of the tree from Seeq to ensure the latest updates are reflected.</p> <p>Returns:</p> Name Type Description <code>Tree</code> <p>The reloaded tree instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an error occurs while loading the tree.</p> Source code in <code>itv_asset_tree/core/tree_loader.py</code> <pre><code>def load_tree(self):\n    \"\"\"\n    Forces a full reload of the tree from Seeq to ensure the latest updates are reflected.\n\n    Returns:\n        Tree: The reloaded tree instance.\n\n    Raises:\n        ValueError: If an error occurs while loading the tree.\n    \"\"\"\n    try:\n        log_info(f\"\ud83d\udd04 Reloading tree '{self.tree_name}' from workbook '{self.workbook}'...\")\n        self.tree = None  # Drop the old reference first\n        self.tree = Tree(self.tree_name, workbook=self.workbook)  # Reload from Seeq\n        log_info(f\"\ud83c\udf33 Tree '{self.tree_name}' reloaded successfully!\")\n        return self.tree\n    except Exception as e:\n        raise ValueError(f\"\u274c Error loading tree '{self.tree_name}': {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_manager.TreeManager","title":"<code>TreeManager</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for managing asset trees in Seeq.</p> <p>This class defines a blueprint for constructing and clearing asset trees within a specified workbook.</p> Source code in <code>itv_asset_tree/core/tree_manager.py</code> <pre><code>class TreeManager(ABC):\n    \"\"\"\n    Abstract base class for managing asset trees in Seeq.\n\n    This class defines a blueprint for constructing and clearing asset trees within a specified workbook.\n    \"\"\"\n\n    def __init__(self, workbook: str):\n        \"\"\"\n        Initializes the TreeManager with a specified workbook.\n\n        Args:\n            workbook (str): The name of the workbook containing the asset tree.\n        \"\"\"\n        self.workbook = workbook\n        self.tree = None\n\n    @abstractmethod\n    def build_tree(self, friendly_name: str, description: str):\n        \"\"\"\n        Constructs a new tree with the specified name and description.\n\n        Args:\n            friendly_name (str): The display name of the tree.\n            description (str): A description of the tree.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def clear_existing_tree(self, tree_name: str):\n        \"\"\"\n        Clears an existing tree by its name, removing it from the workbook.\n\n        Args:\n            tree_name (str): The name of the tree to be cleared.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_manager.TreeManager.__init__","title":"<code>__init__(workbook)</code>","text":"<p>Initializes the TreeManager with a specified workbook.</p> <p>Parameters:</p> Name Type Description Default <code>workbook</code> <code>str</code> <p>The name of the workbook containing the asset tree.</p> required Source code in <code>itv_asset_tree/core/tree_manager.py</code> <pre><code>def __init__(self, workbook: str):\n    \"\"\"\n    Initializes the TreeManager with a specified workbook.\n\n    Args:\n        workbook (str): The name of the workbook containing the asset tree.\n    \"\"\"\n    self.workbook = workbook\n    self.tree = None\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_manager.TreeManager.build_tree","title":"<code>build_tree(friendly_name, description)</code>  <code>abstractmethod</code>","text":"<p>Constructs a new tree with the specified name and description.</p> <p>Parameters:</p> Name Type Description Default <code>friendly_name</code> <code>str</code> <p>The display name of the tree.</p> required <code>description</code> <code>str</code> <p>A description of the tree.</p> required Source code in <code>itv_asset_tree/core/tree_manager.py</code> <pre><code>@abstractmethod\ndef build_tree(self, friendly_name: str, description: str):\n    \"\"\"\n    Constructs a new tree with the specified name and description.\n\n    Args:\n        friendly_name (str): The display name of the tree.\n        description (str): A description of the tree.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_manager.TreeManager.clear_existing_tree","title":"<code>clear_existing_tree(tree_name)</code>  <code>abstractmethod</code>","text":"<p>Clears an existing tree by its name, removing it from the workbook.</p> <p>Parameters:</p> Name Type Description Default <code>tree_name</code> <code>str</code> <p>The name of the tree to be cleared.</p> required Source code in <code>itv_asset_tree/core/tree_manager.py</code> <pre><code>@abstractmethod\ndef clear_existing_tree(self, tree_name: str):\n    \"\"\"\n    Clears an existing tree by its name, removing it from the workbook.\n\n    Args:\n        tree_name (str): The name of the tree to be cleared.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_modifier_factory.TreeModifierFactory","title":"<code>TreeModifierFactory</code>","text":"<p>Factory for creating TreeModifier instances with the correct push strategy.</p> <p>This factory enables flexible creation of TreeModifier instances with different push strategies, allowing for immediate, batched, or dry-run modifications.</p> Source code in <code>itv_asset_tree/core/tree_modifier_factory.py</code> <pre><code>class TreeModifierFactory:\n    \"\"\"\n    Factory for creating TreeModifier instances with the correct push strategy.\n\n    This factory enables flexible creation of TreeModifier instances with different\n    push strategies, allowing for immediate, batched, or dry-run modifications.\n    \"\"\"\n\n    @staticmethod\n    def create(workbook: str, tree_name: str, strategy: str = \"immediate\") -&gt; TreeModifier:\n        \"\"\"\n        Creates a TreeModifier instance with a specified push strategy.\n\n        Args:\n            workbook (str): The name of the workbook containing the tree.\n            tree_name (str): The name of the tree to be modified.\n            strategy (str, optional): The push strategy to apply. Options are:\n                - \"immediate\" (default): Pushes changes instantly.\n                - \"batch\": Queues changes and commits them later.\n                - \"dry_run\": Simulates the push operation without modifying Seeq.\n                - None: Disables push behavior, useful for read-only operations.\n\n        Returns:\n            TreeModifier: A configured TreeModifier instance.\n        \"\"\"\n\n        # If no strategy is provided (e.g., for searching), disable push\n        if strategy is None:\n            log_info(f\"\ud83c\udfed [Factory] Creating TreeModifier for '{tree_name}' in SEARCH mode (no push).\")\n            return TreeModifier(workbook, tree_name, push_strategy=None)\n\n        # Convert strategy name into an instance of the correct PushStrategy class\n        strategy_mapping = {\n            \"immediate\": ImmediatePush(),\n            \"batch\": BatchPush(),\n            \"dry_run\": DryRunPush()\n        }\n\n        push_strategy = strategy_mapping.get(strategy.lower(), ImmediatePush())  # Default: ImmediatePush\n\n        log_info(f\"\ud83c\udfed [Factory] Creating TreeModifier for '{tree_name}' with push strategy: {strategy}\")\n\n        return TreeModifier(workbook, tree_name, push_strategy=push_strategy)\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_modifier_factory.TreeModifierFactory.create","title":"<code>create(workbook, tree_name, strategy='immediate')</code>  <code>staticmethod</code>","text":"<p>Creates a TreeModifier instance with a specified push strategy.</p> <p>Parameters:</p> Name Type Description Default <code>workbook</code> <code>str</code> <p>The name of the workbook containing the tree.</p> required <code>tree_name</code> <code>str</code> <p>The name of the tree to be modified.</p> required <code>strategy</code> <code>str</code> <p>The push strategy to apply. Options are: - \"immediate\" (default): Pushes changes instantly. - \"batch\": Queues changes and commits them later. - \"dry_run\": Simulates the push operation without modifying Seeq. - None: Disables push behavior, useful for read-only operations.</p> <code>'immediate'</code> <p>Returns:</p> Name Type Description <code>TreeModifier</code> <code>TreeModifier</code> <p>A configured TreeModifier instance.</p> Source code in <code>itv_asset_tree/core/tree_modifier_factory.py</code> <pre><code>@staticmethod\ndef create(workbook: str, tree_name: str, strategy: str = \"immediate\") -&gt; TreeModifier:\n    \"\"\"\n    Creates a TreeModifier instance with a specified push strategy.\n\n    Args:\n        workbook (str): The name of the workbook containing the tree.\n        tree_name (str): The name of the tree to be modified.\n        strategy (str, optional): The push strategy to apply. Options are:\n            - \"immediate\" (default): Pushes changes instantly.\n            - \"batch\": Queues changes and commits them later.\n            - \"dry_run\": Simulates the push operation without modifying Seeq.\n            - None: Disables push behavior, useful for read-only operations.\n\n    Returns:\n        TreeModifier: A configured TreeModifier instance.\n    \"\"\"\n\n    # If no strategy is provided (e.g., for searching), disable push\n    if strategy is None:\n        log_info(f\"\ud83c\udfed [Factory] Creating TreeModifier for '{tree_name}' in SEARCH mode (no push).\")\n        return TreeModifier(workbook, tree_name, push_strategy=None)\n\n    # Convert strategy name into an instance of the correct PushStrategy class\n    strategy_mapping = {\n        \"immediate\": ImmediatePush(),\n        \"batch\": BatchPush(),\n        \"dry_run\": DryRunPush()\n    }\n\n    push_strategy = strategy_mapping.get(strategy.lower(), ImmediatePush())  # Default: ImmediatePush\n\n    log_info(f\"\ud83c\udfed [Factory] Creating TreeModifier for '{tree_name}' with push strategy: {strategy}\")\n\n    return TreeModifier(workbook, tree_name, push_strategy=push_strategy)\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_modifier.TreeModifier","title":"<code>TreeModifier</code>","text":"<p>               Bases: <code>ITreeInsert</code>, <code>ITreeMove</code>, <code>ITreeRemove</code></p> <p>A class for modifying asset trees in Seeq.</p> Implements <ul> <li>ITreeInsert: insert_item()</li> <li>ITreeMove: move_item()</li> <li>ITreeRemove: remove_item()</li> </ul> Source code in <code>itv_asset_tree/core/tree_modifier.py</code> <pre><code>class TreeModifier(ITreeInsert, ITreeMove, ITreeRemove):\n    \"\"\"\n    A class for modifying asset trees in Seeq.\n\n    Implements:\n      - ITreeInsert: insert_item()\n      - ITreeMove: move_item()\n      - ITreeRemove: remove_item()\n    \"\"\"\n\n    def __init__(self, workbook: str, tree_name: str, push_strategy: PushStrategy = None):\n        \"\"\"\n        Initializes the TreeModifier with a specified workbook, tree name, and push strategy.\n\n        Args:\n            workbook (str): The name of the workbook containing the tree.\n            tree_name (str): The name of the tree to be modified.\n            push_strategy (PushStrategy, optional): The strategy to use when pushing changes. Defaults to ImmediatePush.\n        \"\"\"\n        self.loader = TreeLoader(workbook, tree_name)  \n        self.tree = self.loader.load_tree() \n        log_debug(f\"\u2705 Tree loaded: {self.tree}\")\n        log_debug(f\"\ud83e\udde9 Available methods: {dir(self.tree)}\")\n\n        # Store push strategy as a class attribute (this was missing!)\n        self.push_strategy = push_strategy if push_strategy else ImmediatePush()\n\n        # Initialize PushManager with the selected push strategy\n        self.push_manager = PushManager(self.tree, self.push_strategy)\n\n    def insert_item(self, parent_path: str, item_definition: dict):\n        \"\"\"\n        Inserts an item under a specified parent in the asset tree.\n\n        Args:\n            parent_path (str): The path of the parent node where the item should be inserted.\n            item_definition (dict): A dictionary defining the item's attributes.\n\n        Raises:\n            ValueError: If there is an error inserting the item.\n        \"\"\"\n        log_debug(f\"\ud83d\udccc [DEBUG] insert_item() called with parent_path='{parent_path}', item_definition={item_definition}\")\n\n        try:\n            # Ensure 'FormulaParams' is parsed correctly\n            if \"FormulaParams\" in item_definition and isinstance(item_definition[\"FormulaParams\"], str):\n                try:\n                    item_definition[\"FormulaParams\"] = json.loads(item_definition[\"FormulaParams\"])\n                except json.JSONDecodeError:\n                    raise ValueError(\"\u274c FormulaParams must be a valid JSON object.\")\n\n            # Fix formula formatting\n            if \"Formula\" in item_definition:\n                formula = item_definition[\"Formula\"].strip()\n                if formula and not (formula.startswith('\"') and formula.endswith('\"')):\n                    item_definition[\"Formula\"] = f'\"{formula}\"'\n\n            # Ensure 'Path' is set correctly\n            if \"Path\" not in item_definition or not item_definition[\"Path\"]:\n                item_definition[\"Path\"] = parent_path\n\n            # Insert into the tree\n            self.tree.insert(children=[item_definition], parent=parent_path)\n\n            log_info(f\"\u2705 Successfully inserted '{item_definition['Name']}' under '{parent_path}'.\")\n\n            # PUSH TO SEEQ IF STRATEGY IS ENABLED\n            if self.push_strategy:\n                log_debug(\"\ud83d\ude80 [DEBUG] Executing push strategy after insert...\")\n                self.push_strategy.push(self.tree, metadata_state_file=\"Output/asset_tree_metadata_state_file.pickle.zip\")\n\n        except Exception as e:\n            log_error(f\"\u274c [ERROR] insert_item() failed: {e}\")\n            raise ValueError(f\"Error inserting item: {e}\")\n\n    def move_item(self, source: str, destination: str):\n        \"\"\"\n        Moves an item to a new parent in the tree.\n\n        Args:\n            source (str): The current path of the item.\n            destination (str): The new parent path where the item should be moved.\n\n        Raises:\n            ValueError: If there is an error moving the item.\n        \"\"\"\n        try:\n            log_debug(f\"\ud83d\udccc [DEBUG] move_item() called: source='{source}', destination='{destination}'\")\n            self.tree.move(source=source, destination=destination)\n\n            # PUSH TO SEEQ IF STRATEGY IS ENABLED\n            if self.push_strategy:\n                log_debug(\"\ud83d\ude80 [DEBUG] Executing push strategy after move...\")\n                self.push_strategy.push(self.tree, metadata_state_file=\"Output/asset_tree_metadata_state_file.pickle.zip\")\n\n            log_info(f\"\u2705 Successfully moved '{source}' to '{destination}'.\")\n\n        except Exception as e:\n            log_error(f\"\u274c [ERROR] move_item() failed: {e}\")\n            raise ValueError(f\"\u274c Error moving item: {e}\")\n\n    def remove_item(self, item_path: str):\n        \"\"\"\n        Removes an item from the tree by its full path.\n\n        Args:\n            item_path (str): The full path of the item to be removed.\n\n        Raises:\n            ValueError: If there is an error removing the item.\n        \"\"\"\n        try:\n            log_info(f\"\ud83d\uddd1\ufe0f Removing item at path: {item_path}\")\n            self.tree.remove(item_path)\n\n            # PUSH TO SEEQ IF STRATEGY IS ENABLED\n            if self.push_strategy:\n                log_debug(\"\ud83d\ude80 [DEBUG] Executing push strategy after remove...\")\n                self.push_strategy.push(self.tree, metadata_state_file=\"Output/asset_tree_metadata_state_file.pickle.zip\")\n\n            log_info(f\"\u2705 Successfully removed '{item_path}'.\")\n\n        except Exception as e:\n            log_error(f\"\u274c [ERROR] remove_item() failed: {e}\")\n            raise ValueError(f\"\u274c Error removing item: {e}\")\n\n    def visualize_tree(self):\n        \"\"\"\n        Visualizes the tree structure and captures the output.\n\n        Returns:\n            str: A structured tree visualization.\n\n        Raises:\n            ValueError: If the tree has not been loaded or an error occurs during visualization.\n        \"\"\"\n        if not self.tree:\n            raise ValueError(\"\u274c Tree is not loaded. Call 'load_tree()' first.\")\n\n        try:\n            log_debug(f\"Tree object type: {type(self.tree)}\")\n            log_debug(f\"Tree dir(): {dir(self.tree)}\")\n            visualization_output = io.StringIO()\n            with contextlib.redirect_stdout(visualization_output):\n                self.tree.visualize()\n\n            visualization = visualization_output.getvalue().strip()\n\n            if not visualization:\n                log_debug(\"\u26a0\ufe0f [DEBUG] Visualization is empty, falling back to `summarize()`\")\n                with contextlib.redirect_stdout(visualization_output):\n                    self.tree.summarize()\n                visualization = visualization_output.getvalue().strip()\n\n            log_info(f\"\ud83c\udf33 Captured Tree Visualization:\\n{visualization}\")\n            log_debug(f\"\ud83e\udde9 Tree has children? {hasattr(self.tree, 'children')}\")\n            log_debug(f\"\ud83e\udde9 Number of children: {len(getattr(self.tree, 'children', []))}\")\n\n            return visualization\n\n        except Exception as e:\n            log_error(f\"\u274c [ERROR] Failed to visualize tree: {e}\")\n            return f\"\u26a0\ufe0f Error generating visualization: {str(e)}\"\n\n        except Exception as e:\n            log_error(f\"\u274c [ERROR] Failed to visualize tree: {e}\")\n            return f\"\u26a0\ufe0f Error generating visualization: {str(e)}\"\n\n    def save_changes(self):\n        \"\"\"\n        Pushes the tree using the selected push strategy.\n        \"\"\"\n        self.push_manager.push()\n\n    def archive_tree(self):\n        \"\"\"\n        Archives all items in the current tree using their IDs.\n\n        This is the safest way to 'delete' a tree, since Seeq does not support direct root deletion.\n\n        Raises:\n            ValueError: If the tree is empty or items could not be found.\n        \"\"\"\n        try:\n            log_info(f\"\ud83d\udce6 Archiving all items in tree: {self.tree.name}\")\n\n            # Find the root asset by name\n            root_result = spy.search({\"Name\": self.tree.name, \"Type\": \"Asset\"})\n\n            if root_result.empty:\n                raise ValueError(f\"\u274c Root asset '{self.tree.name}' not found.\")\n\n            # Grab the ID of the root and search all associated items\n            root_id = root_result.iloc[0][\"ID\"]\n            items_in_tree = spy.search(\n                [{\"Asset\": root_id}, {\"ID\": root_id}],\n                workbook=spy.GLOBALS_AND_ALL_WORKBOOKS,\n                all_properties=True\n            )\n\n            if items_in_tree.empty:\n                log_warning(f\"\u26a0\ufe0f No items found under tree '{self.tree.name}' to archive.\")\n                return\n\n            items_in_tree[\"Archived\"] = True\n            spy.push(metadata=items_in_tree)\n\n            log_info(f\"\u2705 Tree '{self.tree.name}' archived successfully.\")\n\n        except Exception as e:\n            log_error(f\"\u274c Failed to archive tree '{self.tree.name}': {e}\")\n            raise ValueError(f\"\u274c Archive operation failed: {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_modifier.TreeModifier.__init__","title":"<code>__init__(workbook, tree_name, push_strategy=None)</code>","text":"<p>Initializes the TreeModifier with a specified workbook, tree name, and push strategy.</p> <p>Parameters:</p> Name Type Description Default <code>workbook</code> <code>str</code> <p>The name of the workbook containing the tree.</p> required <code>tree_name</code> <code>str</code> <p>The name of the tree to be modified.</p> required <code>push_strategy</code> <code>PushStrategy</code> <p>The strategy to use when pushing changes. Defaults to ImmediatePush.</p> <code>None</code> Source code in <code>itv_asset_tree/core/tree_modifier.py</code> <pre><code>def __init__(self, workbook: str, tree_name: str, push_strategy: PushStrategy = None):\n    \"\"\"\n    Initializes the TreeModifier with a specified workbook, tree name, and push strategy.\n\n    Args:\n        workbook (str): The name of the workbook containing the tree.\n        tree_name (str): The name of the tree to be modified.\n        push_strategy (PushStrategy, optional): The strategy to use when pushing changes. Defaults to ImmediatePush.\n    \"\"\"\n    self.loader = TreeLoader(workbook, tree_name)  \n    self.tree = self.loader.load_tree() \n    log_debug(f\"\u2705 Tree loaded: {self.tree}\")\n    log_debug(f\"\ud83e\udde9 Available methods: {dir(self.tree)}\")\n\n    # Store push strategy as a class attribute (this was missing!)\n    self.push_strategy = push_strategy if push_strategy else ImmediatePush()\n\n    # Initialize PushManager with the selected push strategy\n    self.push_manager = PushManager(self.tree, self.push_strategy)\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_modifier.TreeModifier.archive_tree","title":"<code>archive_tree()</code>","text":"<p>Archives all items in the current tree using their IDs.</p> <p>This is the safest way to 'delete' a tree, since Seeq does not support direct root deletion.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tree is empty or items could not be found.</p> Source code in <code>itv_asset_tree/core/tree_modifier.py</code> <pre><code>def archive_tree(self):\n    \"\"\"\n    Archives all items in the current tree using their IDs.\n\n    This is the safest way to 'delete' a tree, since Seeq does not support direct root deletion.\n\n    Raises:\n        ValueError: If the tree is empty or items could not be found.\n    \"\"\"\n    try:\n        log_info(f\"\ud83d\udce6 Archiving all items in tree: {self.tree.name}\")\n\n        # Find the root asset by name\n        root_result = spy.search({\"Name\": self.tree.name, \"Type\": \"Asset\"})\n\n        if root_result.empty:\n            raise ValueError(f\"\u274c Root asset '{self.tree.name}' not found.\")\n\n        # Grab the ID of the root and search all associated items\n        root_id = root_result.iloc[0][\"ID\"]\n        items_in_tree = spy.search(\n            [{\"Asset\": root_id}, {\"ID\": root_id}],\n            workbook=spy.GLOBALS_AND_ALL_WORKBOOKS,\n            all_properties=True\n        )\n\n        if items_in_tree.empty:\n            log_warning(f\"\u26a0\ufe0f No items found under tree '{self.tree.name}' to archive.\")\n            return\n\n        items_in_tree[\"Archived\"] = True\n        spy.push(metadata=items_in_tree)\n\n        log_info(f\"\u2705 Tree '{self.tree.name}' archived successfully.\")\n\n    except Exception as e:\n        log_error(f\"\u274c Failed to archive tree '{self.tree.name}': {e}\")\n        raise ValueError(f\"\u274c Archive operation failed: {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_modifier.TreeModifier.insert_item","title":"<code>insert_item(parent_path, item_definition)</code>","text":"<p>Inserts an item under a specified parent in the asset tree.</p> <p>Parameters:</p> Name Type Description Default <code>parent_path</code> <code>str</code> <p>The path of the parent node where the item should be inserted.</p> required <code>item_definition</code> <code>dict</code> <p>A dictionary defining the item's attributes.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If there is an error inserting the item.</p> Source code in <code>itv_asset_tree/core/tree_modifier.py</code> <pre><code>def insert_item(self, parent_path: str, item_definition: dict):\n    \"\"\"\n    Inserts an item under a specified parent in the asset tree.\n\n    Args:\n        parent_path (str): The path of the parent node where the item should be inserted.\n        item_definition (dict): A dictionary defining the item's attributes.\n\n    Raises:\n        ValueError: If there is an error inserting the item.\n    \"\"\"\n    log_debug(f\"\ud83d\udccc [DEBUG] insert_item() called with parent_path='{parent_path}', item_definition={item_definition}\")\n\n    try:\n        # Ensure 'FormulaParams' is parsed correctly\n        if \"FormulaParams\" in item_definition and isinstance(item_definition[\"FormulaParams\"], str):\n            try:\n                item_definition[\"FormulaParams\"] = json.loads(item_definition[\"FormulaParams\"])\n            except json.JSONDecodeError:\n                raise ValueError(\"\u274c FormulaParams must be a valid JSON object.\")\n\n        # Fix formula formatting\n        if \"Formula\" in item_definition:\n            formula = item_definition[\"Formula\"].strip()\n            if formula and not (formula.startswith('\"') and formula.endswith('\"')):\n                item_definition[\"Formula\"] = f'\"{formula}\"'\n\n        # Ensure 'Path' is set correctly\n        if \"Path\" not in item_definition or not item_definition[\"Path\"]:\n            item_definition[\"Path\"] = parent_path\n\n        # Insert into the tree\n        self.tree.insert(children=[item_definition], parent=parent_path)\n\n        log_info(f\"\u2705 Successfully inserted '{item_definition['Name']}' under '{parent_path}'.\")\n\n        # PUSH TO SEEQ IF STRATEGY IS ENABLED\n        if self.push_strategy:\n            log_debug(\"\ud83d\ude80 [DEBUG] Executing push strategy after insert...\")\n            self.push_strategy.push(self.tree, metadata_state_file=\"Output/asset_tree_metadata_state_file.pickle.zip\")\n\n    except Exception as e:\n        log_error(f\"\u274c [ERROR] insert_item() failed: {e}\")\n        raise ValueError(f\"Error inserting item: {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_modifier.TreeModifier.move_item","title":"<code>move_item(source, destination)</code>","text":"<p>Moves an item to a new parent in the tree.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The current path of the item.</p> required <code>destination</code> <code>str</code> <p>The new parent path where the item should be moved.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If there is an error moving the item.</p> Source code in <code>itv_asset_tree/core/tree_modifier.py</code> <pre><code>def move_item(self, source: str, destination: str):\n    \"\"\"\n    Moves an item to a new parent in the tree.\n\n    Args:\n        source (str): The current path of the item.\n        destination (str): The new parent path where the item should be moved.\n\n    Raises:\n        ValueError: If there is an error moving the item.\n    \"\"\"\n    try:\n        log_debug(f\"\ud83d\udccc [DEBUG] move_item() called: source='{source}', destination='{destination}'\")\n        self.tree.move(source=source, destination=destination)\n\n        # PUSH TO SEEQ IF STRATEGY IS ENABLED\n        if self.push_strategy:\n            log_debug(\"\ud83d\ude80 [DEBUG] Executing push strategy after move...\")\n            self.push_strategy.push(self.tree, metadata_state_file=\"Output/asset_tree_metadata_state_file.pickle.zip\")\n\n        log_info(f\"\u2705 Successfully moved '{source}' to '{destination}'.\")\n\n    except Exception as e:\n        log_error(f\"\u274c [ERROR] move_item() failed: {e}\")\n        raise ValueError(f\"\u274c Error moving item: {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_modifier.TreeModifier.remove_item","title":"<code>remove_item(item_path)</code>","text":"<p>Removes an item from the tree by its full path.</p> <p>Parameters:</p> Name Type Description Default <code>item_path</code> <code>str</code> <p>The full path of the item to be removed.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If there is an error removing the item.</p> Source code in <code>itv_asset_tree/core/tree_modifier.py</code> <pre><code>def remove_item(self, item_path: str):\n    \"\"\"\n    Removes an item from the tree by its full path.\n\n    Args:\n        item_path (str): The full path of the item to be removed.\n\n    Raises:\n        ValueError: If there is an error removing the item.\n    \"\"\"\n    try:\n        log_info(f\"\ud83d\uddd1\ufe0f Removing item at path: {item_path}\")\n        self.tree.remove(item_path)\n\n        # PUSH TO SEEQ IF STRATEGY IS ENABLED\n        if self.push_strategy:\n            log_debug(\"\ud83d\ude80 [DEBUG] Executing push strategy after remove...\")\n            self.push_strategy.push(self.tree, metadata_state_file=\"Output/asset_tree_metadata_state_file.pickle.zip\")\n\n        log_info(f\"\u2705 Successfully removed '{item_path}'.\")\n\n    except Exception as e:\n        log_error(f\"\u274c [ERROR] remove_item() failed: {e}\")\n        raise ValueError(f\"\u274c Error removing item: {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_modifier.TreeModifier.save_changes","title":"<code>save_changes()</code>","text":"<p>Pushes the tree using the selected push strategy.</p> Source code in <code>itv_asset_tree/core/tree_modifier.py</code> <pre><code>def save_changes(self):\n    \"\"\"\n    Pushes the tree using the selected push strategy.\n    \"\"\"\n    self.push_manager.push()\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_modifier.TreeModifier.visualize_tree","title":"<code>visualize_tree()</code>","text":"<p>Visualizes the tree structure and captures the output.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>A structured tree visualization.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the tree has not been loaded or an error occurs during visualization.</p> Source code in <code>itv_asset_tree/core/tree_modifier.py</code> <pre><code>def visualize_tree(self):\n    \"\"\"\n    Visualizes the tree structure and captures the output.\n\n    Returns:\n        str: A structured tree visualization.\n\n    Raises:\n        ValueError: If the tree has not been loaded or an error occurs during visualization.\n    \"\"\"\n    if not self.tree:\n        raise ValueError(\"\u274c Tree is not loaded. Call 'load_tree()' first.\")\n\n    try:\n        log_debug(f\"Tree object type: {type(self.tree)}\")\n        log_debug(f\"Tree dir(): {dir(self.tree)}\")\n        visualization_output = io.StringIO()\n        with contextlib.redirect_stdout(visualization_output):\n            self.tree.visualize()\n\n        visualization = visualization_output.getvalue().strip()\n\n        if not visualization:\n            log_debug(\"\u26a0\ufe0f [DEBUG] Visualization is empty, falling back to `summarize()`\")\n            with contextlib.redirect_stdout(visualization_output):\n                self.tree.summarize()\n            visualization = visualization_output.getvalue().strip()\n\n        log_info(f\"\ud83c\udf33 Captured Tree Visualization:\\n{visualization}\")\n        log_debug(f\"\ud83e\udde9 Tree has children? {hasattr(self.tree, 'children')}\")\n        log_debug(f\"\ud83e\udde9 Number of children: {len(getattr(self.tree, 'children', []))}\")\n\n        return visualization\n\n    except Exception as e:\n        log_error(f\"\u274c [ERROR] Failed to visualize tree: {e}\")\n        return f\"\u26a0\ufe0f Error generating visualization: {str(e)}\"\n\n    except Exception as e:\n        log_error(f\"\u274c [ERROR] Failed to visualize tree: {e}\")\n        return f\"\u26a0\ufe0f Error generating visualization: {str(e)}\"\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_property_manager.TreePropertyManager","title":"<code>TreePropertyManager</code>","text":"<p>Handles applying properties to asset tree items.</p> <p>This class allows for modifying existing items in the asset tree by updating their properties based on provided metadata.</p> Source code in <code>itv_asset_tree/core/tree_property_manager.py</code> <pre><code>class TreePropertyManager:\n    \"\"\"\n    Handles applying properties to asset tree items.\n\n    This class allows for modifying existing items in the asset tree by updating their properties\n    based on provided metadata.\n    \"\"\"\n\n    def __init__(self, tree):\n        \"\"\"\n        Initializes the TreePropertyManager with a specified tree instance.\n\n        Args:\n            tree: The asset tree to which properties will be applied.\n        \"\"\"\n        self.tree = tree\n\n    def apply_properties(self, metadata):\n        \"\"\"\n        Applies properties to existing tree items based on provided metadata.\n\n        Args:\n            metadata (pd.DataFrame): A DataFrame containing metadata with property values.\n\n        Raises:\n            Exception: If there is an error during property application.\n        \"\"\"\n        if metadata is None:\n            log_warning(\"\u26a0\ufe0f No metadata available to apply properties.\")\n            return\n\n        try:\n            for _, row in metadata.iterrows():\n                item_name = row[\"Name\"]\n                properties = {col: row[col] for col in row.index if col not in [\"Name\", \"Formula\", \"FormulaParams\", \"Parent\"]}\n\n                if properties:\n                    log_info(f\"\ud83d\udccc Applying properties to '{item_name}': {properties}\")\n                    self.tree.modify(item_name, properties=properties)\n\n            self.tree.push()\n            log_info(\"\u2705 Properties applied and tree updated!\")\n\n        except Exception as e:\n            log_error(f\"\u274c Error applying properties: {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_property_manager.TreePropertyManager.__init__","title":"<code>__init__(tree)</code>","text":"<p>Initializes the TreePropertyManager with a specified tree instance.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <p>The asset tree to which properties will be applied.</p> required Source code in <code>itv_asset_tree/core/tree_property_manager.py</code> <pre><code>def __init__(self, tree):\n    \"\"\"\n    Initializes the TreePropertyManager with a specified tree instance.\n\n    Args:\n        tree: The asset tree to which properties will be applied.\n    \"\"\"\n    self.tree = tree\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_property_manager.TreePropertyManager.apply_properties","title":"<code>apply_properties(metadata)</code>","text":"<p>Applies properties to existing tree items based on provided metadata.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>DataFrame</code> <p>A DataFrame containing metadata with property values.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If there is an error during property application.</p> Source code in <code>itv_asset_tree/core/tree_property_manager.py</code> <pre><code>def apply_properties(self, metadata):\n    \"\"\"\n    Applies properties to existing tree items based on provided metadata.\n\n    Args:\n        metadata (pd.DataFrame): A DataFrame containing metadata with property values.\n\n    Raises:\n        Exception: If there is an error during property application.\n    \"\"\"\n    if metadata is None:\n        log_warning(\"\u26a0\ufe0f No metadata available to apply properties.\")\n        return\n\n    try:\n        for _, row in metadata.iterrows():\n            item_name = row[\"Name\"]\n            properties = {col: row[col] for col in row.index if col not in [\"Name\", \"Formula\", \"FormulaParams\", \"Parent\"]}\n\n            if properties:\n                log_info(f\"\ud83d\udccc Applying properties to '{item_name}': {properties}\")\n                self.tree.modify(item_name, properties=properties)\n\n        self.tree.push()\n        log_info(\"\u2705 Properties applied and tree updated!\")\n\n    except Exception as e:\n        log_error(f\"\u274c Error applying properties: {e}\")\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_visualizer.TreeVisualizer","title":"<code>TreeVisualizer</code>","text":"<p>Handles visualization of Seeq trees, including in-memory and fetched versions.</p> <p>This class facilitates fetching and storing tree visualizations to optimize performance and minimize redundant API calls.</p> Source code in <code>itv_asset_tree/core/tree_visualizer.py</code> <pre><code>class TreeVisualizer:\n    \"\"\"\n    Handles visualization of Seeq trees, including in-memory and fetched versions.\n\n    This class facilitates fetching and storing tree visualizations to optimize performance\n    and minimize redundant API calls.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the TreeVisualizer instance.\n\n        Attributes:\n            current_tree: Stores the latest fetched tree to prevent redundant API calls.\n        \"\"\"\n        self.current_tree = None  # Stores the latest fetched tree to prevent redundant API calls\n\n    def get_tree_visualization(self, tree_name: str, workbook_name: str):\n        \"\"\"\n        Retrieves the latest tree visualization from memory or Seeq.\n\n        Note: In the accelerator template context, `tree_name` refers to the region name.\n\n        Args:\n            tree_name (str): The name of the tree (region name in some contexts) to visualize.\n            workbook_name (str): The name of the workbook containing the tree.\n\n        Returns:\n            str: The tree visualization output as a formatted string.\n        \"\"\"\n        log_debug(f\"\ud83d\udd0d [DEBUG] Received visualization request for Tree: {tree_name}, Workbook: {workbook_name}\")\n\n        # Check if we already have the tree in memory\n        if self.current_tree and self.current_tree.name == tree_name:\n            log_debug(\"\u2705 [DEBUG] Returning in-memory tree visualization.\")\n            return self._capture_visualization(self.current_tree)\n\n        # Fetch the tree from Seeq if not available in memory\n        return self._fetch_and_visualize_tree(tree_name, workbook_name)\n\n    def _fetch_and_visualize_tree(self, tree_name: str, workbook_name: str):\n        \"\"\"\n        Fetches the tree from Seeq, stores it in memory, and visualizes it.\n\n        Args:\n            tree_name (str): The name of the tree to fetch.\n            workbook_name (str): The name of the workbook containing the tree.\n\n        Returns:\n            str: The tree visualization output, or None if the tree is not found.\n        \"\"\"\n        try:\n            log_debug(f\"\ud83d\udd04 [DEBUG] Fetching tree from Seeq: {tree_name}\")\n\n            tree_modifier = TreeModifierFactory.create(workbook=workbook_name, tree_name=tree_name, operation=\"search\")\n            fetched_tree = tree_modifier.tree  # Load tree properly\n\n            if not fetched_tree:\n                log_debug(f\"\u274c [DEBUG] Tree '{tree_name}' not found!\")\n                return None  # Return None instead of an error dict (handled in the API)\n\n            log_debug(f\"\u2705 [DEBUG] Successfully fetched tree: {tree_name}\")\n\n            # Update in-memory reference\n            self.current_tree = fetched_tree  \n\n            return self._capture_visualization(fetched_tree)\n\n        except Exception as e:\n            log_error(f\"\u274c [ERROR] Failed to visualize tree: {e}\")\n            return None  # Let the API layer handle error response\n\n    def _capture_visualization(self, tree):\n        \"\"\"\n        Captures tree visualization as a string output.\n\n        Args:\n            tree: The tree object to visualize.\n\n        Returns:\n            str: The tree visualization output as a formatted string.\n        \"\"\"\n        visualization_output = io.StringIO()\n        with contextlib.redirect_stdout(visualization_output):\n            tree.visualize() \n        visualization = visualization_output.getvalue()\n        log_debug(f\"\ud83d\udcca [DEBUG] Tree Visualization Output:\\n{visualization}\")\n        return visualization.strip()\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_visualizer.TreeVisualizer.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the TreeVisualizer instance.</p> <p>Attributes:</p> Name Type Description <code>current_tree</code> <p>Stores the latest fetched tree to prevent redundant API calls.</p> Source code in <code>itv_asset_tree/core/tree_visualizer.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Initializes the TreeVisualizer instance.\n\n    Attributes:\n        current_tree: Stores the latest fetched tree to prevent redundant API calls.\n    \"\"\"\n    self.current_tree = None  # Stores the latest fetched tree to prevent redundant API calls\n</code></pre>"},{"location":"#itv_asset_tree.core.tree_visualizer.TreeVisualizer.get_tree_visualization","title":"<code>get_tree_visualization(tree_name, workbook_name)</code>","text":"<p>Retrieves the latest tree visualization from memory or Seeq.</p> <p>Note: In the accelerator template context, <code>tree_name</code> refers to the region name.</p> <p>Parameters:</p> Name Type Description Default <code>tree_name</code> <code>str</code> <p>The name of the tree (region name in some contexts) to visualize.</p> required <code>workbook_name</code> <code>str</code> <p>The name of the workbook containing the tree.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>The tree visualization output as a formatted string.</p> Source code in <code>itv_asset_tree/core/tree_visualizer.py</code> <pre><code>def get_tree_visualization(self, tree_name: str, workbook_name: str):\n    \"\"\"\n    Retrieves the latest tree visualization from memory or Seeq.\n\n    Note: In the accelerator template context, `tree_name` refers to the region name.\n\n    Args:\n        tree_name (str): The name of the tree (region name in some contexts) to visualize.\n        workbook_name (str): The name of the workbook containing the tree.\n\n    Returns:\n        str: The tree visualization output as a formatted string.\n    \"\"\"\n    log_debug(f\"\ud83d\udd0d [DEBUG] Received visualization request for Tree: {tree_name}, Workbook: {workbook_name}\")\n\n    # Check if we already have the tree in memory\n    if self.current_tree and self.current_tree.name == tree_name:\n        log_debug(\"\u2705 [DEBUG] Returning in-memory tree visualization.\")\n        return self._capture_visualization(self.current_tree)\n\n    # Fetch the tree from Seeq if not available in memory\n    return self._fetch_and_visualize_tree(tree_name, workbook_name)\n</code></pre>"},{"location":"#itv_asset_tree.schemas.csv_lookup.CSVLookupRequest","title":"<code>CSVLookupRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema for handling CSV lookup requests.</p> <p>Attributes:</p> Name Type Description <code>csv_file_path</code> <code>str</code> <p>The file path to the CSV file being processed.</p> Source code in <code>itv_asset_tree/schemas/csv_lookup.py</code> <pre><code>class CSVLookupRequest(BaseModel):\n    \"\"\"\n    Schema for handling CSV lookup requests.\n\n    Attributes:\n        csv_file_path (str): The file path to the CSV file being processed.\n    \"\"\"\n    csv_file_path: str\n</code></pre>"},{"location":"#itv_asset_tree.schemas.csv_lookup.CSVLookupResponse","title":"<code>CSVLookupResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema for CSV lookup responses.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>dict</code> <p>The parsed data extracted from the CSV file.</p> Source code in <code>itv_asset_tree/schemas/csv_lookup.py</code> <pre><code>class CSVLookupResponse(BaseModel):\n    \"\"\"\n    Schema for CSV lookup responses.\n\n    Attributes:\n        data (dict): The parsed data extracted from the CSV file.\n    \"\"\"\n    data: dict\n</code></pre>"},{"location":"#itv_asset_tree.schemas.tree.TreeCreateRequest","title":"<code>TreeCreateRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema for creating a new asset tree in Seeq.</p> <p>Attributes:</p> Name Type Description <code>workbook_name</code> <code>str</code> <p>The name of the workbook where the tree will be created.</p> <code>csv_file_path</code> <code>str</code> <p>The file path to the CSV file containing the tree structure.</p> Source code in <code>itv_asset_tree/schemas/tree.py</code> <pre><code>class TreeCreateRequest(BaseModel):\n    \"\"\"\n    Schema for creating a new asset tree in Seeq.\n\n    Attributes:\n        workbook_name (str): The name of the workbook where the tree will be created.\n        csv_file_path (str): The file path to the CSV file containing the tree structure.\n    \"\"\"\n    workbook_name: str\n    csv_file_path: str\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Compressor","title":"<code>Compressor</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Represents a Compressor asset with power and condition attributes.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>class Compressor(Asset):\n    \"\"\"\n    Represents a Compressor asset with power and condition attributes.\n    \"\"\"\n    @Asset.Attribute()\n    def Power(self, metadata):\n        \"\"\"\n        Retrieves the power signal for the compressor.\n\n        Returns:\n            DataFrame: Filtered metadata containing power signals.\n        \"\"\"\n        # Each compressor has just a single attribute, Power\n        return metadata[metadata['Name'].str.endswith('Power')]\n\n    @Asset.Attribute()\n    def High_Power(self, metadata):\n        \"\"\"\n        Identifies when the compressor power exceeds 20kW.\n\n        Returns:\n            Condition: A condition representing high power usage.\n        \"\"\"\n        return {\n            'Type': 'Condition',\n            'Formula': '$a.valueSearch(isGreaterThan(20kW))',\n            'Formula Parameters': {\n                '$a': self.Power()\n            }\n        }\n\n    @Asset.Attribute()\n    def Other_Compressors_Are_High_Power(self, metadata):\n        \"\"\"\n        Determines if other sibling Compressors are also in high power state.\n\n        Returns:\n            Condition: A rolled-up union condition across sibling Compressors.\n        \"\"\"\n        # This is a more complex example of using self.all_assets() where we want to\n        # look at sibling assets as opposed to parents/children, and do a roll up.\n        # Here the \"if\" statement selects Compressor assets where our parent and\n        # their parent are the same but we exclude ourselves.\n        return ItemGroup([\n            asset.High_Power() for asset in self.all_assets()\n            if isinstance(asset, Compressor) and self.parent == asset.parent and self != asset\n        ]).roll_up('union')\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Compressor.High_Power","title":"<code>High_Power(metadata)</code>","text":"<p>Identifies when the compressor power exceeds 20kW.</p> <p>Returns:</p> Name Type Description <code>Condition</code> <p>A condition representing high power usage.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef High_Power(self, metadata):\n    \"\"\"\n    Identifies when the compressor power exceeds 20kW.\n\n    Returns:\n        Condition: A condition representing high power usage.\n    \"\"\"\n    return {\n        'Type': 'Condition',\n        'Formula': '$a.valueSearch(isGreaterThan(20kW))',\n        'Formula Parameters': {\n            '$a': self.Power()\n        }\n    }\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Compressor.Other_Compressors_Are_High_Power","title":"<code>Other_Compressors_Are_High_Power(metadata)</code>","text":"<p>Determines if other sibling Compressors are also in high power state.</p> <p>Returns:</p> Name Type Description <code>Condition</code> <p>A rolled-up union condition across sibling Compressors.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Other_Compressors_Are_High_Power(self, metadata):\n    \"\"\"\n    Determines if other sibling Compressors are also in high power state.\n\n    Returns:\n        Condition: A rolled-up union condition across sibling Compressors.\n    \"\"\"\n    # This is a more complex example of using self.all_assets() where we want to\n    # look at sibling assets as opposed to parents/children, and do a roll up.\n    # Here the \"if\" statement selects Compressor assets where our parent and\n    # their parent are the same but we exclude ourselves.\n    return ItemGroup([\n        asset.High_Power() for asset in self.all_assets()\n        if isinstance(asset, Compressor) and self.parent == asset.parent and self != asset\n    ]).roll_up('union')\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Compressor.Power","title":"<code>Power(metadata)</code>","text":"<p>Retrieves the power signal for the compressor.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>Filtered metadata containing power signals.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Power(self, metadata):\n    \"\"\"\n    Retrieves the power signal for the compressor.\n\n    Returns:\n        DataFrame: Filtered metadata containing power signals.\n    \"\"\"\n    # Each compressor has just a single attribute, Power\n    return metadata[metadata['Name'].str.endswith('Power')]\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Facility","title":"<code>Facility</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Represents a Facility containing one or more Sections.</p> Components <p>Sections (AssetGroup): Grouped by the 'Section' column, these define the internal structure of the Facility.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>class Facility(Asset):\n    \"\"\"\n    Represents a Facility containing one or more Sections.\n\n    Components:\n        Sections (AssetGroup): Grouped by the 'Section' column, these define the internal structure of the Facility.\n    \"\"\"\n\n    @Asset.Component()\n    def Sections(self, metadata):\n        \"\"\"\n        Assigns Section components to the Facility.\n\n        Args:\n            metadata (DataFrame): Signal metadata.\n\n        Returns:\n            AssetGroup: Group of Sections based on the 'Section' column.\n        \"\"\"\n        return self.build_components(Section, metadata, column_name='Section')\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Facility.Sections","title":"<code>Sections(metadata)</code>","text":"<p>Assigns Section components to the Facility.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>DataFrame</code> <p>Signal metadata.</p> required <p>Returns:</p> Name Type Description <code>AssetGroup</code> <p>Group of Sections based on the 'Section' column.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Component()\ndef Sections(self, metadata):\n    \"\"\"\n    Assigns Section components to the Facility.\n\n    Args:\n        metadata (DataFrame): Signal metadata.\n\n    Returns:\n        AssetGroup: Group of Sections based on the 'Section' column.\n    \"\"\"\n    return self.build_components(Section, metadata, column_name='Section')\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Refrigerator","title":"<code>Refrigerator</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Represents a Refrigerator asset with temperature and compressor attributes.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>class Refrigerator(Asset):\n    \"\"\"\n    Represents a Refrigerator asset with temperature and compressor attributes.\n    \"\"\"\n    @Asset.Attribute()\n    def Temperature(self, metadata):\n        \"\"\"\n        Returns the temperature signals associated with the Refrigerator.\n\n        Returns:\n            DataFrame: Filtered metadata containing temperature signals.\n        \"\"\"\n        # This signal attribute is assigned to the Refrigerator asset\n        return metadata[metadata['Name'].str.endswith('Temperature')]\n\n    # Note the use of Asset.Component here, which allows us to return a list of definitions\n    # instead of just a single definition.\n    @Asset.Component()\n    def Compressors(self, metadata):\n        \"\"\"\n        Assigns Compressor components to the Refrigerator.\n\n        Returns:\n            AssetGroup: A group of Compressor assets built from the metadata using the 'Compressor' column.\n        \"\"\"\n        # Using the Compressor template class, we build all of the compressor definitions\n        # associated with a particular Refrigerator. The column_name supplied tells the\n        # build_components function which metadata column to use for the Compressor names.\n        return self.build_components(template=Compressor, metadata=metadata, column_name='Compressor')\n\n    @Asset.Attribute()\n    def Compressor_Power_Max(self, metadata):\n        \"\"\"\n        Computes the maximum compressor power across all child Compressors.\n\n        Returns:\n            Signal: A rolled-up signal representing the maximum compressor power.\n        \"\"\"\n        # We can refer to the Compressors and \"pick\" attributes for which to perform a\n        # roll up. In this example, we're picking the 'Power' signals that are on each\n        # compressor and creating a new signal representing the maximum power across\n        # all the compressors.\n        return self.Compressors().pick({\n            'Name': 'Power'\n        }).roll_up('maximum')\n\n    @Asset.Attribute()\n    def Compressor_High_Power(self, metadata):\n        \"\"\"\n        Determines if any child Compressor has a high power condition.\n\n        Returns:\n            Condition: A union of 'High Power' conditions from all child Compressors.\n        \"\"\"\n        # Similar to Compressor_Power_Max, we are rolling up a compressor calculation but\n        # this time it's a condition. 'High Power' at the Refrigerator level will have\n        # capsules if either compressor's 'High Power' condition is present.\n        #\n        # This time we'll use a different method of picking the child items than we used\n        # in Compressor_Power_Max() above. In this case, we're going to select the set of\n        # compressors that are owned by this asset from the entire set of assets, and use\n        # Python conditional logic to find the \"High Power\" conditions. What you see\n        # below is called a Python \"list comprehension\" that combines iteration over all\n        # assets (the \"for/in\" construct) with filtering (the \"if\" statement).\n        #\n        # Helpful functions:\n        #  asset.is_child_of(self)      - Is the asset one of my direct children?\n        #  asset.is_parent_of(self)     - Is the asset my direct parent?\n        #  asset.is_descendant_of(self) - Is the asset below me in the tree?\n        #  asset.is_ancestor_of(self)   - Is the asset above me? (i.e. parent/grandparent/great-grandparent/etc)\n        #\n        return ItemGroup([\n            asset.High_Power() for asset in self.all_assets()\n            if asset.is_child_of(self)\n        ]).roll_up('union')\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Refrigerator.Compressor_High_Power","title":"<code>Compressor_High_Power(metadata)</code>","text":"<p>Determines if any child Compressor has a high power condition.</p> <p>Returns:</p> Name Type Description <code>Condition</code> <p>A union of 'High Power' conditions from all child Compressors.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Compressor_High_Power(self, metadata):\n    \"\"\"\n    Determines if any child Compressor has a high power condition.\n\n    Returns:\n        Condition: A union of 'High Power' conditions from all child Compressors.\n    \"\"\"\n    # Similar to Compressor_Power_Max, we are rolling up a compressor calculation but\n    # this time it's a condition. 'High Power' at the Refrigerator level will have\n    # capsules if either compressor's 'High Power' condition is present.\n    #\n    # This time we'll use a different method of picking the child items than we used\n    # in Compressor_Power_Max() above. In this case, we're going to select the set of\n    # compressors that are owned by this asset from the entire set of assets, and use\n    # Python conditional logic to find the \"High Power\" conditions. What you see\n    # below is called a Python \"list comprehension\" that combines iteration over all\n    # assets (the \"for/in\" construct) with filtering (the \"if\" statement).\n    #\n    # Helpful functions:\n    #  asset.is_child_of(self)      - Is the asset one of my direct children?\n    #  asset.is_parent_of(self)     - Is the asset my direct parent?\n    #  asset.is_descendant_of(self) - Is the asset below me in the tree?\n    #  asset.is_ancestor_of(self)   - Is the asset above me? (i.e. parent/grandparent/great-grandparent/etc)\n    #\n    return ItemGroup([\n        asset.High_Power() for asset in self.all_assets()\n        if asset.is_child_of(self)\n    ]).roll_up('union')\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Refrigerator.Compressor_Power_Max","title":"<code>Compressor_Power_Max(metadata)</code>","text":"<p>Computes the maximum compressor power across all child Compressors.</p> <p>Returns:</p> Name Type Description <code>Signal</code> <p>A rolled-up signal representing the maximum compressor power.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Compressor_Power_Max(self, metadata):\n    \"\"\"\n    Computes the maximum compressor power across all child Compressors.\n\n    Returns:\n        Signal: A rolled-up signal representing the maximum compressor power.\n    \"\"\"\n    # We can refer to the Compressors and \"pick\" attributes for which to perform a\n    # roll up. In this example, we're picking the 'Power' signals that are on each\n    # compressor and creating a new signal representing the maximum power across\n    # all the compressors.\n    return self.Compressors().pick({\n        'Name': 'Power'\n    }).roll_up('maximum')\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Refrigerator.Compressors","title":"<code>Compressors(metadata)</code>","text":"<p>Assigns Compressor components to the Refrigerator.</p> <p>Returns:</p> Name Type Description <code>AssetGroup</code> <p>A group of Compressor assets built from the metadata using the 'Compressor' column.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Component()\ndef Compressors(self, metadata):\n    \"\"\"\n    Assigns Compressor components to the Refrigerator.\n\n    Returns:\n        AssetGroup: A group of Compressor assets built from the metadata using the 'Compressor' column.\n    \"\"\"\n    # Using the Compressor template class, we build all of the compressor definitions\n    # associated with a particular Refrigerator. The column_name supplied tells the\n    # build_components function which metadata column to use for the Compressor names.\n    return self.build_components(template=Compressor, metadata=metadata, column_name='Compressor')\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Refrigerator.Temperature","title":"<code>Temperature(metadata)</code>","text":"<p>Returns the temperature signals associated with the Refrigerator.</p> <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>Filtered metadata containing temperature signals.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Temperature(self, metadata):\n    \"\"\"\n    Returns the temperature signals associated with the Refrigerator.\n\n    Returns:\n        DataFrame: Filtered metadata containing temperature signals.\n    \"\"\"\n    # This signal attribute is assigned to the Refrigerator asset\n    return metadata[metadata['Name'].str.endswith('Temperature')]\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Region","title":"<code>Region</code>","text":"<p>               Bases: <code>Asset</code></p> <p>A Region represents the top-level node in the HVAC asset tree hierarchy.</p> Components <p>Facilities (AssetGroup): Facility components grouped by the 'Facility' column.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>class Region(Asset):\n    \"\"\"\n    A Region represents the top-level node in the HVAC asset tree hierarchy.\n\n    Components:\n        Facilities (AssetGroup): Facility components grouped by the 'Facility' column.\n    \"\"\"\n\n    @Asset.Component()\n    def Facilities(self, metadata):\n        \"\"\"\n        Assigns Facility components to the Region.\n\n        Args:\n            metadata (DataFrame): Signal metadata.\n\n        Returns:\n            AssetGroup: Group of Facilities based on the 'Facility' column.\n        \"\"\"\n        return self.build_components(Facility, metadata, column_name='Facility')\n\n    @staticmethod\n    def get_hierarchy_config() -&gt; dict[str, str]:\n        \"\"\"\n        Returns configuration for the HVAC hierarchy template.\n\n        Returns:\n            dict: Dictionary containing the entry point and hierarchy description.\n        \"\"\"\n        return {\n            \"entry_point\": \"Region\",\n            \"description\": \"Standard HVAC hierarchy: Region &gt; Facility &gt; Section &gt; Component\"\n        }\n\n    @staticmethod\n    def get_build_config() -&gt; dict:\n        \"\"\"\n        Specifies template-level build configuration flags.\n\n        Returns:\n            dict: Configuration flags used by the build system.\n        \"\"\"\n        return {\n            \"requires_component_column\": True\n        }\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Region.Facilities","title":"<code>Facilities(metadata)</code>","text":"<p>Assigns Facility components to the Region.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>DataFrame</code> <p>Signal metadata.</p> required <p>Returns:</p> Name Type Description <code>AssetGroup</code> <p>Group of Facilities based on the 'Facility' column.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Component()\ndef Facilities(self, metadata):\n    \"\"\"\n    Assigns Facility components to the Region.\n\n    Args:\n        metadata (DataFrame): Signal metadata.\n\n    Returns:\n        AssetGroup: Group of Facilities based on the 'Facility' column.\n    \"\"\"\n    return self.build_components(Facility, metadata, column_name='Facility')\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Region.get_build_config","title":"<code>get_build_config()</code>  <code>staticmethod</code>","text":"<p>Specifies template-level build configuration flags.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration flags used by the build system.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@staticmethod\ndef get_build_config() -&gt; dict:\n    \"\"\"\n    Specifies template-level build configuration flags.\n\n    Returns:\n        dict: Configuration flags used by the build system.\n    \"\"\"\n    return {\n        \"requires_component_column\": True\n    }\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Region.get_hierarchy_config","title":"<code>get_hierarchy_config()</code>  <code>staticmethod</code>","text":"<p>Returns configuration for the HVAC hierarchy template.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, str]</code> <p>Dictionary containing the entry point and hierarchy description.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@staticmethod\ndef get_hierarchy_config() -&gt; dict[str, str]:\n    \"\"\"\n    Returns configuration for the HVAC hierarchy template.\n\n    Returns:\n        dict: Dictionary containing the entry point and hierarchy description.\n    \"\"\"\n    return {\n        \"entry_point\": \"Region\",\n        \"description\": \"Standard HVAC hierarchy: Region &gt; Facility &gt; Section &gt; Component\"\n    }\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section","title":"<code>Section</code>","text":"<p>               Bases: <code>Asset</code></p> <p>A Section contains HVAC-related signals, calculations, and KPIs.</p> <p>Attributes:</p> Name Type Description <code>Temperature</code> <code>Signal</code> <p>Signals ending with 'Temperature'.</p> <code>Humidity</code> <code>Signal</code> <p>Signals ending with 'Humidity'.</p> <code>Compressor_Power</code> <code>Signal</code> <p>Signals ending with 'Power'.</p> <code>Temperature_Rate_Of_Change</code> <code>Signal</code> <p>Calculated derivative of low-pass filtered temperature.</p> <code>Too_Hot</code> <code>Condition</code> <p>Condition where temperature exceeds a threshold.</p> <code>Hot_Threshold</code> <code>Scalar</code> <p>Static threshold value of 80F.</p> <code>Too_Humid</code> <code>Condition</code> <p>Condition where humidity exceeds 70%.</p> <code>Humidity_Upper_Bound</code> <code>Signal</code> <p>Humidity plus 10.</p> <code>Humidity_Lower_Bound</code> <code>Signal</code> <p>Humidity minus 10.</p> <code>Humidity_Statistic_KPI</code> <code>Metric</code> <p>KPI for humidity range.</p> <code>Humidity_Simple_KPI</code> <code>Metric</code> <p>KPI for humidity with thresholds.</p> <code>Humidity_Condition_KPI</code> <code>Metric</code> <p>KPI for max humidity when too humid.</p> <code>Humidity_Continuous_KPI</code> <code>Metric</code> <p>Continuous KPI for humidity.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>class Section(Asset):\n    \"\"\"\n    A Section contains HVAC-related signals, calculations, and KPIs.\n\n    Attributes:\n        Temperature (Signal): Signals ending with 'Temperature'.\n        Humidity (Signal): Signals ending with 'Humidity'.\n        Compressor_Power (Signal): Signals ending with 'Power'.\n        Temperature_Rate_Of_Change (Signal): Calculated derivative of low-pass filtered temperature.\n        Too_Hot (Condition): Condition where temperature exceeds a threshold.\n        Hot_Threshold (Scalar): Static threshold value of 80F.\n        Too_Humid (Condition): Condition where humidity exceeds 70%.\n        Humidity_Upper_Bound (Signal): Humidity plus 10.\n        Humidity_Lower_Bound (Signal): Humidity minus 10.\n        Humidity_Statistic_KPI (Metric): KPI for humidity range.\n        Humidity_Simple_KPI (Metric): KPI for humidity with thresholds.\n        Humidity_Condition_KPI (Metric): KPI for max humidity when too humid.\n        Humidity_Continuous_KPI (Metric): Continuous KPI for humidity.\n    \"\"\"\n\n    @Asset.Attribute()\n    def Temperature(self, metadata):\n        \"\"\"\n        Retrieves temperature signals associated with the section.\n\n        Args:\n            metadata (DataFrame): Signal metadata.\n\n        Returns:\n            DataFrame: Filtered metadata for signals ending with 'Temperature'.\n        \"\"\"\n        return metadata[metadata['Name'].str.endswith('Temperature')]\n\n    @Asset.Attribute()\n    def Humidity(self, metadata):\n        \"\"\"\n        Retrieves humidity signals associated with the section.\n\n        Args:\n            metadata (DataFrame): Signal metadata.\n\n        Returns:\n            DataFrame: Filtered metadata for signals ending with 'Humidity'.\n        \"\"\"\n        return metadata[metadata['Name'].str.endswith('Humidity')]\n\n    @Asset.Attribute()\n    def Compressor_Power(self, metadata):\n        \"\"\"\n        Retrieves compressor power signals associated with the section.\n\n        Args:\n            metadata (DataFrame): Signal metadata.\n\n        Returns:\n            DataFrame: Filtered metadata for signals ending with 'Power'.\n        \"\"\"\n        return metadata[metadata['Name'].str.endswith('Power')]\n\n    # Calculations\n    @Asset.Attribute()\n    def Temperature_Rate_Of_Change(self, metadata):\n        \"\"\"\n        Calculates the rate of change of low-pass filtered temperature.\n\n        Returns:\n            dict: A signal definition with derivative formula.\n        \"\"\"\n        return {\n            'Type': 'Signal',\n            'Formula': '$temp.lowPassFilter(150min, 3min, 333).derivative() * 3600 s/h',\n            'Formula Parameters': {\n                '$temp': self.Temperature(),\n            }\n        }\n\n    @Asset.Attribute()\n    def Too_Hot(self, metadata):\n        \"\"\"\n        Generates a condition when temperature exceeds a threshold.\n\n        Returns:\n            dict: A condition definition based on a scalar threshold.\n        \"\"\"\n        return {\n            'Type': 'Condition',\n            'Formula': '$temp.valueSearch(isGreaterThan($threshold))',\n            'Formula Parameters': {\n                '$temp': self.Temperature(),\n                '$threshold': self.Hot_Threshold()\n            }\n        }\n\n    @Asset.Attribute()\n    def Hot_Threshold(self, metadata):\n        \"\"\"\n        Provides the scalar threshold for detecting high temperature.\n\n        Returns:\n            dict: A static scalar threshold of 80F.\n        \"\"\"\n        return {\n            'Type': 'Scalar',\n            'Formula': '80F'\n        }\n\n    # Metrics\n    @Asset.Attribute()\n    def Too_Humid(self, metadata):\n        \"\"\"\n        Generates a condition when humidity exceeds 70%.\n\n        Returns:\n            dict: A condition definition based on a humidity threshold.\n        \"\"\"\n        return {\n            'Type': 'Condition',\n            'Name': 'Too Humid',\n            'Formula': '$relhumid.valueSearch(isGreaterThan(70%))',\n            'Formula Parameters': {\n                '$relhumid': self.Humidity(),\n            }\n        }\n\n    @Asset.Attribute()\n    def Humidity_Upper_Bound(self, metadata):\n        \"\"\"\n        Defines a humidity signal upper bound (humidity + 10).\n\n        Returns:\n            dict: A signal formula with a 10% offset above humidity.\n        \"\"\"\n        return {\n            'Type': 'Signal',\n            'Name': 'Humidity Upper Bound',\n            'Formula': '$relhumid + 10',\n            'Formula Parameters': {\n                '$relhumid': self.Humidity(),\n            }\n        }\n\n    @Asset.Attribute()\n    def Humidity_Lower_Bound(self, metadata):\n        \"\"\"\n        Defines a humidity signal lower bound (humidity - 10).\n\n        Returns:\n            dict: A signal formula with a 10% offset below humidity.\n        \"\"\"\n        return {\n            'Type': 'Signal',\n            'Name': 'Humidity Lower Bound',\n            'Formula': '$relhumid - 10',\n            'Formula Parameters': {\n                '$relhumid': self.Humidity(),\n            }\n        }\n\n    @Asset.Attribute()\n    def Humidity_Statistic_KPI(self, metadata):\n        \"\"\"\n        Defines a KPI metric for the range of humidity values.\n\n        Returns:\n            dict: A metric measuring the humidity signal range.\n        \"\"\"\n        return {\n            'Type': 'Metric',\n            'Measured Item': self.Humidity(),\n            'Statistic': 'Range'\n        }\n\n    @Asset.Attribute()\n    def Humidity_Simple_KPI(self, metadata):\n        \"\"\"\n        Defines a KPI with static high and low threshold values for humidity.\n\n        Returns:\n            dict: A metric with HiHi and LoLo thresholds based on humidity bounds.\n        \"\"\"\n        return {\n            'Type': 'Metric',\n            'Measured Item': self.Humidity(),\n            'Thresholds': {\n                'HiHi': self.Humidity_Upper_Bound(),\n                'LoLo': self.Humidity_Lower_Bound()\n            }\n        }\n\n    @Asset.Attribute()\n    def Humidity_Condition_KPI(self, metadata):\n        \"\"\"\n        Defines a KPI metric for the maximum humidity during 'Too Humid' conditions.\n\n        Returns:\n            dict: A KPI metric bounded by the 'Too Humid' condition with max stat.\n        \"\"\"\n        return {\n            'Type': 'Metric',\n            'Measured Item': self.Humidity(),\n            'Statistic': 'Maximum',\n            'Bounding Condition': self.Too_Humid(),\n            'Bounding Condition Maximum Duration': '30h'\n        }\n\n    @Asset.Attribute()\n    def Humidity_Continuous_KPI(self, metadata):\n        \"\"\"\n        Defines a continuous KPI metric for minimum humidity over a rolling time window.\n\n        Returns:\n            dict: A KPI metric with thresholds and duration configuration.\n        \"\"\"\n        return {\n            'Type': 'Metric',\n            'Measured Item': self.Humidity(),\n            'Statistic': 'Minimum',\n            'Duration': '6h',\n            'Period': '4h',\n            'Metric Neutral Color': '#189E4D',\n            'Thresholds': {\n                'HiHiHi#FF0000': 60,\n                'HiHi': 40,\n                'LoLo#0000ff': 20\n            }\n        }\n\n    # NEW: Assign Components to Sections\n    @Asset.Component()\n    def Compressors(self, metadata):\n        \"\"\"\n        Assigns Compressor components to this Section if they exist.\n\n        Returns:\n            AssetGroup: Compressors assigned to this section by the 'Component' column.\n        \"\"\"\n        return self.build_components(Compressor, metadata, column_name='Component')\n\n    @Asset.Component()\n    def Refrigerators(self, metadata):\n        \"\"\"\n        Assigns Refrigerator components to this Section if they exist.\n\n        Returns:\n            AssetGroup: Refrigerators assigned to this section by the 'Component' column.\n        \"\"\"\n        return self.build_components(Refrigerator, metadata, column_name='Component')\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Compressor_Power","title":"<code>Compressor_Power(metadata)</code>","text":"<p>Retrieves compressor power signals associated with the section.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>DataFrame</code> <p>Signal metadata.</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>Filtered metadata for signals ending with 'Power'.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Compressor_Power(self, metadata):\n    \"\"\"\n    Retrieves compressor power signals associated with the section.\n\n    Args:\n        metadata (DataFrame): Signal metadata.\n\n    Returns:\n        DataFrame: Filtered metadata for signals ending with 'Power'.\n    \"\"\"\n    return metadata[metadata['Name'].str.endswith('Power')]\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Compressors","title":"<code>Compressors(metadata)</code>","text":"<p>Assigns Compressor components to this Section if they exist.</p> <p>Returns:</p> Name Type Description <code>AssetGroup</code> <p>Compressors assigned to this section by the 'Component' column.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Component()\ndef Compressors(self, metadata):\n    \"\"\"\n    Assigns Compressor components to this Section if they exist.\n\n    Returns:\n        AssetGroup: Compressors assigned to this section by the 'Component' column.\n    \"\"\"\n    return self.build_components(Compressor, metadata, column_name='Component')\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Hot_Threshold","title":"<code>Hot_Threshold(metadata)</code>","text":"<p>Provides the scalar threshold for detecting high temperature.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A static scalar threshold of 80F.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Hot_Threshold(self, metadata):\n    \"\"\"\n    Provides the scalar threshold for detecting high temperature.\n\n    Returns:\n        dict: A static scalar threshold of 80F.\n    \"\"\"\n    return {\n        'Type': 'Scalar',\n        'Formula': '80F'\n    }\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Humidity","title":"<code>Humidity(metadata)</code>","text":"<p>Retrieves humidity signals associated with the section.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>DataFrame</code> <p>Signal metadata.</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>Filtered metadata for signals ending with 'Humidity'.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Humidity(self, metadata):\n    \"\"\"\n    Retrieves humidity signals associated with the section.\n\n    Args:\n        metadata (DataFrame): Signal metadata.\n\n    Returns:\n        DataFrame: Filtered metadata for signals ending with 'Humidity'.\n    \"\"\"\n    return metadata[metadata['Name'].str.endswith('Humidity')]\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Humidity_Condition_KPI","title":"<code>Humidity_Condition_KPI(metadata)</code>","text":"<p>Defines a KPI metric for the maximum humidity during 'Too Humid' conditions.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A KPI metric bounded by the 'Too Humid' condition with max stat.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Humidity_Condition_KPI(self, metadata):\n    \"\"\"\n    Defines a KPI metric for the maximum humidity during 'Too Humid' conditions.\n\n    Returns:\n        dict: A KPI metric bounded by the 'Too Humid' condition with max stat.\n    \"\"\"\n    return {\n        'Type': 'Metric',\n        'Measured Item': self.Humidity(),\n        'Statistic': 'Maximum',\n        'Bounding Condition': self.Too_Humid(),\n        'Bounding Condition Maximum Duration': '30h'\n    }\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Humidity_Continuous_KPI","title":"<code>Humidity_Continuous_KPI(metadata)</code>","text":"<p>Defines a continuous KPI metric for minimum humidity over a rolling time window.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A KPI metric with thresholds and duration configuration.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Humidity_Continuous_KPI(self, metadata):\n    \"\"\"\n    Defines a continuous KPI metric for minimum humidity over a rolling time window.\n\n    Returns:\n        dict: A KPI metric with thresholds and duration configuration.\n    \"\"\"\n    return {\n        'Type': 'Metric',\n        'Measured Item': self.Humidity(),\n        'Statistic': 'Minimum',\n        'Duration': '6h',\n        'Period': '4h',\n        'Metric Neutral Color': '#189E4D',\n        'Thresholds': {\n            'HiHiHi#FF0000': 60,\n            'HiHi': 40,\n            'LoLo#0000ff': 20\n        }\n    }\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Humidity_Lower_Bound","title":"<code>Humidity_Lower_Bound(metadata)</code>","text":"<p>Defines a humidity signal lower bound (humidity - 10).</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A signal formula with a 10% offset below humidity.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Humidity_Lower_Bound(self, metadata):\n    \"\"\"\n    Defines a humidity signal lower bound (humidity - 10).\n\n    Returns:\n        dict: A signal formula with a 10% offset below humidity.\n    \"\"\"\n    return {\n        'Type': 'Signal',\n        'Name': 'Humidity Lower Bound',\n        'Formula': '$relhumid - 10',\n        'Formula Parameters': {\n            '$relhumid': self.Humidity(),\n        }\n    }\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Humidity_Simple_KPI","title":"<code>Humidity_Simple_KPI(metadata)</code>","text":"<p>Defines a KPI with static high and low threshold values for humidity.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A metric with HiHi and LoLo thresholds based on humidity bounds.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Humidity_Simple_KPI(self, metadata):\n    \"\"\"\n    Defines a KPI with static high and low threshold values for humidity.\n\n    Returns:\n        dict: A metric with HiHi and LoLo thresholds based on humidity bounds.\n    \"\"\"\n    return {\n        'Type': 'Metric',\n        'Measured Item': self.Humidity(),\n        'Thresholds': {\n            'HiHi': self.Humidity_Upper_Bound(),\n            'LoLo': self.Humidity_Lower_Bound()\n        }\n    }\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Humidity_Statistic_KPI","title":"<code>Humidity_Statistic_KPI(metadata)</code>","text":"<p>Defines a KPI metric for the range of humidity values.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A metric measuring the humidity signal range.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Humidity_Statistic_KPI(self, metadata):\n    \"\"\"\n    Defines a KPI metric for the range of humidity values.\n\n    Returns:\n        dict: A metric measuring the humidity signal range.\n    \"\"\"\n    return {\n        'Type': 'Metric',\n        'Measured Item': self.Humidity(),\n        'Statistic': 'Range'\n    }\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Humidity_Upper_Bound","title":"<code>Humidity_Upper_Bound(metadata)</code>","text":"<p>Defines a humidity signal upper bound (humidity + 10).</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A signal formula with a 10% offset above humidity.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Humidity_Upper_Bound(self, metadata):\n    \"\"\"\n    Defines a humidity signal upper bound (humidity + 10).\n\n    Returns:\n        dict: A signal formula with a 10% offset above humidity.\n    \"\"\"\n    return {\n        'Type': 'Signal',\n        'Name': 'Humidity Upper Bound',\n        'Formula': '$relhumid + 10',\n        'Formula Parameters': {\n            '$relhumid': self.Humidity(),\n        }\n    }\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Refrigerators","title":"<code>Refrigerators(metadata)</code>","text":"<p>Assigns Refrigerator components to this Section if they exist.</p> <p>Returns:</p> Name Type Description <code>AssetGroup</code> <p>Refrigerators assigned to this section by the 'Component' column.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Component()\ndef Refrigerators(self, metadata):\n    \"\"\"\n    Assigns Refrigerator components to this Section if they exist.\n\n    Returns:\n        AssetGroup: Refrigerators assigned to this section by the 'Component' column.\n    \"\"\"\n    return self.build_components(Refrigerator, metadata, column_name='Component')\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Temperature","title":"<code>Temperature(metadata)</code>","text":"<p>Retrieves temperature signals associated with the section.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>DataFrame</code> <p>Signal metadata.</p> required <p>Returns:</p> Name Type Description <code>DataFrame</code> <p>Filtered metadata for signals ending with 'Temperature'.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Temperature(self, metadata):\n    \"\"\"\n    Retrieves temperature signals associated with the section.\n\n    Args:\n        metadata (DataFrame): Signal metadata.\n\n    Returns:\n        DataFrame: Filtered metadata for signals ending with 'Temperature'.\n    \"\"\"\n    return metadata[metadata['Name'].str.endswith('Temperature')]\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Temperature_Rate_Of_Change","title":"<code>Temperature_Rate_Of_Change(metadata)</code>","text":"<p>Calculates the rate of change of low-pass filtered temperature.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A signal definition with derivative formula.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Temperature_Rate_Of_Change(self, metadata):\n    \"\"\"\n    Calculates the rate of change of low-pass filtered temperature.\n\n    Returns:\n        dict: A signal definition with derivative formula.\n    \"\"\"\n    return {\n        'Type': 'Signal',\n        'Formula': '$temp.lowPassFilter(150min, 3min, 333).derivative() * 3600 s/h',\n        'Formula Parameters': {\n            '$temp': self.Temperature(),\n        }\n    }\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Too_Hot","title":"<code>Too_Hot(metadata)</code>","text":"<p>Generates a condition when temperature exceeds a threshold.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A condition definition based on a scalar threshold.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Too_Hot(self, metadata):\n    \"\"\"\n    Generates a condition when temperature exceeds a threshold.\n\n    Returns:\n        dict: A condition definition based on a scalar threshold.\n    \"\"\"\n    return {\n        'Type': 'Condition',\n        'Formula': '$temp.valueSearch(isGreaterThan($threshold))',\n        'Formula Parameters': {\n            '$temp': self.Temperature(),\n            '$threshold': self.Hot_Threshold()\n        }\n    }\n</code></pre>"},{"location":"#itv_asset_tree.templates.hvac_template.Section.Too_Humid","title":"<code>Too_Humid(metadata)</code>","text":"<p>Generates a condition when humidity exceeds 70%.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A condition definition based on a humidity threshold.</p> Source code in <code>itv_asset_tree/templates/hvac_template.py</code> <pre><code>@Asset.Attribute()\ndef Too_Humid(self, metadata):\n    \"\"\"\n    Generates a condition when humidity exceeds 70%.\n\n    Returns:\n        dict: A condition definition based on a humidity threshold.\n    \"\"\"\n    return {\n        'Type': 'Condition',\n        'Name': 'Too Humid',\n        'Formula': '$relhumid.valueSearch(isGreaterThan(70%))',\n        'Formula Parameters': {\n            '$relhumid': self.Humidity(),\n        }\n    }\n</code></pre>"},{"location":"#itv_asset_tree.templates.valve_template.Compressor","title":"<code>Compressor</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Compressor-related signals.</p> Source code in <code>itv_asset_tree/templates/valve_template.py</code> <pre><code>class Compressor(Asset):\n    \"\"\"Compressor-related signals.\"\"\"\n\n    @Asset.Attribute()\n    def Recycle_Flow(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_5']\n\n    @Asset.Attribute()\n    def Compressor_Work(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_20']\n</code></pre>"},{"location":"#itv_asset_tree.templates.valve_template.Facility","title":"<code>Facility</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Each Facility contains either Sections or direct components.</p> Source code in <code>itv_asset_tree/templates/valve_template.py</code> <pre><code>class Facility(Asset):\n    \"\"\"Each Facility contains either Sections or direct components.\"\"\"\n\n    @Asset.Component()\n    def DynamicStructure(self, metadata):\n        print(\"\ud83d\udce6 DEBUG: Received metadata for Facility:\")\n        print(metadata[[\"Name\", \"Section\", \"Component\"]].head(10))\n        # Force fallback ONLY if all values are missing or empty strings\n        if 'Section' not in metadata.columns or metadata['Section'].fillna('').str.strip().eq('').all():\n            # Build components directly under Facility\n            return [\n                *self.build_components(Compressor, metadata, column_name=\"Component\"),\n                *self.build_components(Valve, metadata, column_name=\"Component\"),\n                *self.build_components(Feed, metadata, column_name=\"Component\"),\n                *self.build_components(Purge, metadata, column_name=\"Component\"),\n                *self.build_components(Reactor, metadata, column_name=\"Component\"),\n                *self.build_components(Separator, metadata, column_name=\"Component\"),\n                *self.build_components(Stripper, metadata, column_name=\"Component\"),\n                *self.build_components(Product, metadata, column_name=\"Component\"),\n                *self.build_components(General, metadata, column_name=\"Component\"),\n            ]\n        else:\n            # Proceed with Section-level breakdown\n            return self.build_components(Section, metadata, column_name='Section')\n</code></pre>"},{"location":"#itv_asset_tree.templates.valve_template.Feed","title":"<code>Feed</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Feed-related signals.</p> Source code in <code>itv_asset_tree/templates/valve_template.py</code> <pre><code>class Feed(Asset):\n    \"\"\"Feed-related signals.\"\"\"\n\n    @Asset.Attribute()\n    def A_Feed(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_1']\n\n    @Asset.Attribute()\n    def D_Feed(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_2']\n\n    @Asset.Attribute()\n    def E_Feed(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_3']\n\n    @Asset.Attribute()\n    def Total_Feed(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_4']\n</code></pre>"},{"location":"#itv_asset_tree.templates.valve_template.General","title":"<code>General</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Miscellaneous or diagnostic signals.</p> Source code in <code>itv_asset_tree/templates/valve_template.py</code> <pre><code>class General(Asset):\n    \"\"\"Miscellaneous or diagnostic signals.\"\"\"\n\n    @Asset.Attribute()\n    def Fault_Number(self, metadata):\n        return metadata[metadata['Name'] == 'faultNumber']\n\n    @Asset.Attribute()\n    def Simulation_Run(self, metadata):\n        return metadata[metadata['Name'] == 'simulationRun']\n</code></pre>"},{"location":"#itv_asset_tree.templates.valve_template.Product","title":"<code>Product</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Product composition signals.</p> Source code in <code>itv_asset_tree/templates/valve_template.py</code> <pre><code>class Product(Asset):\n    \"\"\"Product composition signals.\"\"\"\n\n    @Asset.Attribute()\n    def Comp_D(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_36']\n\n    @Asset.Attribute()\n    def Comp_E(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_37']\n\n    @Asset.Attribute()\n    def Comp_F(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_38']\n\n    @Asset.Attribute()\n    def Comp_G(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_39']\n\n    @Asset.Attribute()\n    def Comp_H(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_40']\n</code></pre>"},{"location":"#itv_asset_tree.templates.valve_template.Purge","title":"<code>Purge</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Purge-related signals.</p> Source code in <code>itv_asset_tree/templates/valve_template.py</code> <pre><code>class Purge(Asset):\n    \"\"\"Purge-related signals.\"\"\"\n\n    @Asset.Attribute()\n    def Purge_Rate(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_10']\n\n    @Asset.Attribute()\n    def Comp_A(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_31']\n\n    @Asset.Attribute()\n    def Comp_B(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_32']\n\n    @Asset.Attribute()\n    def Comp_C(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_33']\n\n    @Asset.Attribute()\n    def Comp_D(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_34']\n\n    @Asset.Attribute()\n    def Comp_E(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_35']\n</code></pre>"},{"location":"#itv_asset_tree.templates.valve_template.Reactor","title":"<code>Reactor</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Reactor-related signals.</p> Source code in <code>itv_asset_tree/templates/valve_template.py</code> <pre><code>class Reactor(Asset):\n    \"\"\"Reactor-related signals.\"\"\"\n\n    @Asset.Attribute()\n    def Feed_Rate(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_6']\n\n    @Asset.Attribute()\n    def CW_Outlet_Temp(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_21']\n\n    @Asset.Attribute()\n    def Level(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_8']\n\n    @Asset.Attribute()\n    def Temperature(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_9']\n\n    @Asset.Attribute()\n    def Pressure(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_7']\n\n    @Asset.Attribute()\n    def Comp_A(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_23']\n\n    @Asset.Attribute()\n    def Comp_B(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_24']\n\n    @Asset.Attribute()\n    def Comp_C(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_25']\n\n    @Asset.Attribute()\n    def Comp_D(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_26']\n\n    @Asset.Attribute()\n    def Comp_E(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_27']\n\n    @Asset.Attribute()\n    def Comp_F(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_28']\n\n    @Asset.Attribute()\n    def Comp_G(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_29']\n\n    @Asset.Attribute()\n    def Comp_H(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_30']\n</code></pre>"},{"location":"#itv_asset_tree.templates.valve_template.Region","title":"<code>Region</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Top-level Region asset.</p> Source code in <code>itv_asset_tree/templates/valve_template.py</code> <pre><code>class Region(Asset):\n    \"\"\"Top-level Region asset.\"\"\"\n\n    @Asset.Component()\n    def Facilities(self, metadata):\n        return self.build_components(Facility, metadata, column_name='Facility')\n\n    @staticmethod\n    def get_hierarchy_config() -&gt; dict[str, str]:\n        return {\n            \"entry_point\": \"Region\",\n            \"description\": \"TEP Process Hierarchy using raw tag names\"\n        }\n\n    @staticmethod\n    def get_build_config() -&gt; dict:\n        \"\"\"\n        Specifies template-level build configuration flags.\n\n        Returns:\n            dict: Configuration flags used by the build system.\n        \"\"\"\n        return {\n            \"requires_component_column\": False\n        }\n</code></pre>"},{"location":"#itv_asset_tree.templates.valve_template.Region.get_build_config","title":"<code>get_build_config()</code>  <code>staticmethod</code>","text":"<p>Specifies template-level build configuration flags.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Configuration flags used by the build system.</p> Source code in <code>itv_asset_tree/templates/valve_template.py</code> <pre><code>@staticmethod\ndef get_build_config() -&gt; dict:\n    \"\"\"\n    Specifies template-level build configuration flags.\n\n    Returns:\n        dict: Configuration flags used by the build system.\n    \"\"\"\n    return {\n        \"requires_component_column\": False\n    }\n</code></pre>"},{"location":"#itv_asset_tree.templates.valve_template.Section","title":"<code>Section</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Each Section contains multiple components.</p> Source code in <code>itv_asset_tree/templates/valve_template.py</code> <pre><code>class Section(Asset):\n    \"\"\"Each Section contains multiple components.\"\"\"\n\n    @Asset.Component()\n    def Compressors(self, metadata):\n        return self.build_components(Compressor, metadata, column_name='Component')\n\n    @Asset.Component()\n    def Valves(self, metadata):\n        return self.build_components(Valve, metadata, column_name='Component')\n\n    @Asset.Component()\n    def Feeds(self, metadata):\n        return self.build_components(Feed, metadata, column_name='Component')\n\n    @Asset.Component()\n    def Purges(self, metadata):\n        return self.build_components(Purge, metadata, column_name='Component')\n\n    @Asset.Component()\n    def Reactors(self, metadata):\n        return self.build_components(Reactor, metadata, column_name='Component')\n\n    @Asset.Component()\n    def Separators(self, metadata):\n        return self.build_components(Separator, metadata, column_name='Component')\n\n    @Asset.Component()\n    def Strippers(self, metadata):\n        return self.build_components(Stripper, metadata, column_name='Component')\n\n    @Asset.Component()\n    def Products(self, metadata):\n        return self.build_components(Product, metadata, column_name='Component')\n\n    @Asset.Component()\n    def General(self, metadata):\n        return self.build_components(General, metadata, column_name='Component')\n</code></pre>"},{"location":"#itv_asset_tree.templates.valve_template.Separator","title":"<code>Separator</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Separator-related signals.</p> Source code in <code>itv_asset_tree/templates/valve_template.py</code> <pre><code>class Separator(Asset):\n    \"\"\"Separator-related signals.\"\"\"\n\n    @Asset.Attribute()\n    def Level(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_12']\n\n    @Asset.Attribute()\n    def Pressure(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_13']\n\n    @Asset.Attribute()\n    def Underflow(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_14']\n\n    @Asset.Attribute()\n    def CW_Outlet_Temp(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_22']\n\n    @Asset.Attribute()\n    def Temperature(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_11']\n</code></pre>"},{"location":"#itv_asset_tree.templates.valve_template.Stripper","title":"<code>Stripper</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Stripper-related signals.</p> Source code in <code>itv_asset_tree/templates/valve_template.py</code> <pre><code>class Stripper(Asset):\n    \"\"\"Stripper-related signals.\"\"\"\n\n    @Asset.Attribute()\n    def Level(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_15']\n\n    @Asset.Attribute()\n    def Pressure(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_16']\n\n    @Asset.Attribute()\n    def Underflow(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_17']\n\n    @Asset.Attribute()\n    def Temperature(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_18']\n\n    @Asset.Attribute()\n    def Steam_Flow(self, metadata):\n        return metadata[metadata['Name'] == 'xmeas_19']\n</code></pre>"},{"location":"#itv_asset_tree.templates.valve_template.Valve","title":"<code>Valve</code>","text":"<p>               Bases: <code>Asset</code></p> <p>Valve-related signals (xmv_*).</p> Source code in <code>itv_asset_tree/templates/valve_template.py</code> <pre><code>class Valve(Asset):\n    \"\"\"Valve-related signals (xmv_*).\"\"\"\n\n    @Asset.Attribute()\n    def Compressor_Recycle_Valve(self, metadata):\n        return metadata[metadata['Name'] == 'xmv_5']\n\n    @Asset.Attribute()\n    def Condenser_CW_Valve(self, metadata):\n        return metadata[metadata['Name'] == 'xmv_11']\n\n    @Asset.Attribute()\n    def D_Feed_Valve(self, metadata):\n        return metadata[metadata['Name'] == 'xmv_1']\n\n    @Asset.Attribute()\n    def E_Feed_Valve(self, metadata):\n        return metadata[metadata['Name'] == 'xmv_2']\n\n    @Asset.Attribute()\n    def A_Feed_Valve(self, metadata):\n        return metadata[metadata['Name'] == 'xmv_3']\n\n    @Asset.Attribute()\n    def Total_Feed_Valve(self, metadata):\n        return metadata[metadata['Name'] == 'xmv_4']\n\n    @Asset.Attribute()\n    def Purge_Valve(self, metadata):\n        return metadata[metadata['Name'] == 'xmv_6']\n\n    @Asset.Attribute()\n    def Separator_Product_Flow_Valve(self, metadata):\n        return metadata[metadata['Name'] == 'xmv_7']\n\n    @Asset.Attribute()\n    def Stripper_Product_Flow_Valve(self, metadata):\n        return metadata[metadata['Name'] == 'xmv_8']\n\n    @Asset.Attribute()\n    def Stripper_Steam_Valve(self, metadata):\n        return metadata[metadata['Name'] == 'xmv_9']\n</code></pre>"},{"location":"#itv_asset_tree.utils.cleaning.clean_signal_leaf_name","title":"<code>clean_signal_leaf_name(name)</code>","text":"<p>Cleans a raw signal name for use as the Build Asset leaf.</p> <p>This trims off known prefixes to avoid recursive tree nesting.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The raw signal name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A cleaned, simple name for display in the tree.</p> Source code in <code>itv_asset_tree/utils/cleaning.py</code> <pre><code>def clean_signal_leaf_name(name: str) -&gt; str:\n    \"\"\"\n    Cleans a raw signal name for use as the Build Asset leaf.\n\n    This trims off known prefixes to avoid recursive tree nesting.\n\n    Args:\n        name (str): The raw signal name.\n\n    Returns:\n        str: A cleaned, simple name for display in the tree.\n    \"\"\"\n    if not isinstance(name, str):\n        return name\n    return name.split(\"_\")[-1].strip() if \"_\" in name else name.strip()\n</code></pre>"},{"location":"#itv_asset_tree.utils.cleaning.extract_component_column","title":"<code>extract_component_column(df)</code>","text":"<p>Extracts the component from the 'Name' column using component patterns from config.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Signal metadata.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame with a 'Component' column added.</p> Source code in <code>itv_asset_tree/utils/cleaning.py</code> <pre><code>def extract_component_column(df: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    Extracts the component from the 'Name' column using component patterns from config.\n\n    Args:\n        df (pd.DataFrame): Signal metadata.\n\n    Returns:\n        pd.DataFrame: DataFrame with a 'Component' column added.\n    \"\"\"\n    component_patterns = get_config_value(\"templates.components\")\n\n    if not component_patterns:\n        log_warning(\"\u26a0\ufe0f No component patterns found in config.yaml \u2192 skipping component extraction.\")\n        df[\"Component\"] = None\n        return df\n\n    pattern = \"|\".join([re.escape(comp) for comp in component_patterns])\n    df[\"Component\"] = df[\"Name\"].str.extract(rf\"({pattern})\", flags=re.IGNORECASE)[0]\n\n    log_info(f\"\u2705 Extracted Components using regex: {pattern}\")\n    log_info(\"\ud83d\udccc Unique Components Extracted:\")\n    log_info(df[\"Component\"].value_counts().to_string())\n\n    return df\n</code></pre>"},{"location":"#itv_asset_tree.utils.csv_parser.CSVHandler","title":"<code>CSVHandler</code>","text":"<p>Handles CSV loading and validation.</p> <p>This class provides methods to load and validate CSV files.</p> Source code in <code>itv_asset_tree/utils/csv_parser.py</code> <pre><code>class CSVHandler:\n    \"\"\"\n    Handles CSV loading and validation.\n\n    This class provides methods to load and validate CSV files.\n    \"\"\"\n\n    def __init__(self, csv_path):\n        \"\"\"\n        Initializes the CSVHandler with a specified CSV file path.\n\n        Args:\n            csv_path (str): The path to the CSV file to be loaded.\n        \"\"\"\n        self.csv_path = csv_path\n        self.data = None\n\n    def load_csv(self):\n        \"\"\"\n        Loads the CSV file into a pandas DataFrame.\n\n        Returns:\n            pd.DataFrame: A DataFrame containing the CSV data.\n\n        Raises:\n            FileNotFoundError: If the specified CSV file does not exist.\n        \"\"\"\n        if not os.path.exists(self.csv_path):\n            raise FileNotFoundError(f\"\u274c File '{self.csv_path}' not found.\")\n\n        self.data = pd.read_csv(self.csv_path)\n        log_info(\"\u2705 CSV loaded successfully.\\n\")\n        log_info(\"\ud83d\udcca Columns in the file:\", list(self.data.columns))\n        return self.data\n</code></pre>"},{"location":"#itv_asset_tree.utils.csv_parser.CSVHandler.__init__","title":"<code>__init__(csv_path)</code>","text":"<p>Initializes the CSVHandler with a specified CSV file path.</p> <p>Parameters:</p> Name Type Description Default <code>csv_path</code> <code>str</code> <p>The path to the CSV file to be loaded.</p> required Source code in <code>itv_asset_tree/utils/csv_parser.py</code> <pre><code>def __init__(self, csv_path):\n    \"\"\"\n    Initializes the CSVHandler with a specified CSV file path.\n\n    Args:\n        csv_path (str): The path to the CSV file to be loaded.\n    \"\"\"\n    self.csv_path = csv_path\n    self.data = None\n</code></pre>"},{"location":"#itv_asset_tree.utils.csv_parser.CSVHandler.load_csv","title":"<code>load_csv()</code>","text":"<p>Loads the CSV file into a pandas DataFrame.</p> <p>Returns:</p> Type Description <p>pd.DataFrame: A DataFrame containing the CSV data.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the specified CSV file does not exist.</p> Source code in <code>itv_asset_tree/utils/csv_parser.py</code> <pre><code>def load_csv(self):\n    \"\"\"\n    Loads the CSV file into a pandas DataFrame.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing the CSV data.\n\n    Raises:\n        FileNotFoundError: If the specified CSV file does not exist.\n    \"\"\"\n    if not os.path.exists(self.csv_path):\n        raise FileNotFoundError(f\"\u274c File '{self.csv_path}' not found.\")\n\n    self.data = pd.read_csv(self.csv_path)\n    log_info(\"\u2705 CSV loaded successfully.\\n\")\n    log_info(\"\ud83d\udcca Columns in the file:\", list(self.data.columns))\n    return self.data\n</code></pre>"},{"location":"#itv_asset_tree.utils.duplicate_resolution.DuplicateResolver","title":"<code>DuplicateResolver</code>","text":"<p>Resolves duplicates within a dataset based on user-selected strategies.</p> Source code in <code>itv_asset_tree/utils/duplicate_resolution.py</code> <pre><code>class DuplicateResolver:\n    \"\"\"\n    Resolves duplicates within a dataset based on user-selected strategies.\n    \"\"\"\n    def __init__(self, strategy: DuplicateStrategy):\n        \"\"\"\n        Initializes the resolver with a specified duplicate resolution strategy.\n\n        Args:\n            strategy (DuplicateStrategy): The strategy to use for resolving duplicates.\n        \"\"\"\n        self.strategy = strategy\n\n    def resolve_group(self, group, group_name, key_column):\n        \"\"\"\n        Resolves duplicates within a single group of data.\n\n        Args:\n            group (pd.DataFrame): The group of data containing potential duplicates.\n            group_name (str): The name of the group being processed.\n            key_column (str): The column used to determine duplicates.\n\n        Returns:\n            pd.DataFrame: A DataFrame with resolved duplicates.\n        \"\"\"\n        duplicates = group[group.duplicated(subset=key_column, keep=False)]\n        if duplicates.empty:\n            log_info(f\"\u2705 No duplicates found in group '{group_name}'.\")\n            return group\n\n        log_info(f\"\\n\u2705 Resolving duplicates for group: {group_name}\")\n        log_info(duplicates[[key_column]])\n\n        log_info(f\"\u2192 Group Name: {group_name}\")\n        log_info(f\"\u26a0\ufe0f Duplicates detected: {len(duplicates)}\")\n        # print(f\"Resolved group size: {len(resolved_group)}\")\n\n        resolved_group = self.strategy.resolve(group, key_column)\n        return resolved_group\n</code></pre>"},{"location":"#itv_asset_tree.utils.duplicate_resolution.DuplicateResolver.__init__","title":"<code>__init__(strategy)</code>","text":"<p>Initializes the resolver with a specified duplicate resolution strategy.</p> <p>Parameters:</p> Name Type Description Default <code>strategy</code> <code>DuplicateStrategy</code> <p>The strategy to use for resolving duplicates.</p> required Source code in <code>itv_asset_tree/utils/duplicate_resolution.py</code> <pre><code>def __init__(self, strategy: DuplicateStrategy):\n    \"\"\"\n    Initializes the resolver with a specified duplicate resolution strategy.\n\n    Args:\n        strategy (DuplicateStrategy): The strategy to use for resolving duplicates.\n    \"\"\"\n    self.strategy = strategy\n</code></pre>"},{"location":"#itv_asset_tree.utils.duplicate_resolution.DuplicateResolver.resolve_group","title":"<code>resolve_group(group, group_name, key_column)</code>","text":"<p>Resolves duplicates within a single group of data.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>DataFrame</code> <p>The group of data containing potential duplicates.</p> required <code>group_name</code> <code>str</code> <p>The name of the group being processed.</p> required <code>key_column</code> <code>str</code> <p>The column used to determine duplicates.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: A DataFrame with resolved duplicates.</p> Source code in <code>itv_asset_tree/utils/duplicate_resolution.py</code> <pre><code>def resolve_group(self, group, group_name, key_column):\n    \"\"\"\n    Resolves duplicates within a single group of data.\n\n    Args:\n        group (pd.DataFrame): The group of data containing potential duplicates.\n        group_name (str): The name of the group being processed.\n        key_column (str): The column used to determine duplicates.\n\n    Returns:\n        pd.DataFrame: A DataFrame with resolved duplicates.\n    \"\"\"\n    duplicates = group[group.duplicated(subset=key_column, keep=False)]\n    if duplicates.empty:\n        log_info(f\"\u2705 No duplicates found in group '{group_name}'.\")\n        return group\n\n    log_info(f\"\\n\u2705 Resolving duplicates for group: {group_name}\")\n    log_info(duplicates[[key_column]])\n\n    log_info(f\"\u2192 Group Name: {group_name}\")\n    log_info(f\"\u26a0\ufe0f Duplicates detected: {len(duplicates)}\")\n    # print(f\"Resolved group size: {len(resolved_group)}\")\n\n    resolved_group = self.strategy.resolve(group, key_column)\n    return resolved_group\n</code></pre>"},{"location":"#itv_asset_tree.utils.duplicate_resolution.DuplicateStrategy","title":"<code>DuplicateStrategy</code>","text":"<p>Base class for duplicate resolution strategies.</p> <p>Subclasses must implement the <code>resolve</code> method to specify how duplicates should be handled.</p> Source code in <code>itv_asset_tree/utils/duplicate_resolution.py</code> <pre><code>class DuplicateStrategy:\n    \"\"\"\n    Base class for duplicate resolution strategies.\n\n    Subclasses must implement the `resolve` method to specify how duplicates should be handled.\n    \"\"\"\n    def resolve(self, group, key_column):\n        \"\"\"\n        Resolves duplicates within a given group.\n\n        Args:\n            group (pd.DataFrame): The group of data containing potential duplicates.\n            key_column (str): The column used to determine duplicates.\n\n        Returns:\n            pd.DataFrame: A DataFrame with duplicates resolved according to the strategy.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"#itv_asset_tree.utils.duplicate_resolution.DuplicateStrategy.resolve","title":"<code>resolve(group, key_column)</code>","text":"<p>Resolves duplicates within a given group.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>DataFrame</code> <p>The group of data containing potential duplicates.</p> required <code>key_column</code> <code>str</code> <p>The column used to determine duplicates.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: A DataFrame with duplicates resolved according to the strategy.</p> Source code in <code>itv_asset_tree/utils/duplicate_resolution.py</code> <pre><code>def resolve(self, group, key_column):\n    \"\"\"\n    Resolves duplicates within a given group.\n\n    Args:\n        group (pd.DataFrame): The group of data containing potential duplicates.\n        key_column (str): The column used to determine duplicates.\n\n    Returns:\n        pd.DataFrame: A DataFrame with duplicates resolved according to the strategy.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"#itv_asset_tree.utils.duplicate_resolution.KeepFirstStrategy","title":"<code>KeepFirstStrategy</code>","text":"<p>               Bases: <code>DuplicateStrategy</code></p> <p>Strategy that keeps the first occurrence of each duplicate and removes the rest.</p> Source code in <code>itv_asset_tree/utils/duplicate_resolution.py</code> <pre><code>class KeepFirstStrategy(DuplicateStrategy):\n    \"\"\"\n    Strategy that keeps the first occurrence of each duplicate and removes the rest.\n    \"\"\"\n    def resolve(self, group, key_column):\n        return group.drop_duplicates(subset=key_column, keep='first')\n</code></pre>"},{"location":"#itv_asset_tree.utils.duplicate_resolution.KeepLastStrategy","title":"<code>KeepLastStrategy</code>","text":"<p>               Bases: <code>DuplicateStrategy</code></p> <p>Strategy that keeps the last occurrence of each duplicate and removes the rest.</p> Source code in <code>itv_asset_tree/utils/duplicate_resolution.py</code> <pre><code>class KeepLastStrategy(DuplicateStrategy):\n    \"\"\"\n    Strategy that keeps the last occurrence of each duplicate and removes the rest.\n    \"\"\"\n    def resolve(self, group, key_column):\n        return group.drop_duplicates(subset=key_column, keep='last')\n</code></pre>"},{"location":"#itv_asset_tree.utils.duplicate_resolution.RemoveAllStrategy","title":"<code>RemoveAllStrategy</code>","text":"<p>               Bases: <code>DuplicateStrategy</code></p> <p>Strategy that removes all occurrences of a duplicate.</p> Source code in <code>itv_asset_tree/utils/duplicate_resolution.py</code> <pre><code>class RemoveAllStrategy(DuplicateStrategy):\n    \"\"\"\n    Strategy that removes all occurrences of a duplicate.\n    \"\"\"\n    def resolve(self, group, key_column):\n        return group[~group.duplicated(subset=key_column, keep=False)]\n</code></pre>"},{"location":"#itv_asset_tree.utils.duplicate_resolution.UserSpecificStrategy","title":"<code>UserSpecificStrategy</code>","text":"<p>               Bases: <code>DuplicateStrategy</code></p> <p>Strategy that keeps user-specified rows while removing others.</p> Source code in <code>itv_asset_tree/utils/duplicate_resolution.py</code> <pre><code>class UserSpecificStrategy(DuplicateStrategy):\n    \"\"\"\n    Strategy that keeps user-specified rows while removing others.\n    \"\"\"\n    def __init__(self, rows_to_keep):\n        \"\"\"\n        Initializes the strategy with a list of row indices to keep.\n\n        Args:\n            rows_to_keep (list[int]): List of indices indicating rows to keep.\n        \"\"\"\n        self.rows_to_keep = rows_to_keep\n\n    def resolve(self, group, key_column):\n        return group.iloc[self.rows_to_keep]\n</code></pre>"},{"location":"#itv_asset_tree.utils.duplicate_resolution.UserSpecificStrategy.__init__","title":"<code>__init__(rows_to_keep)</code>","text":"<p>Initializes the strategy with a list of row indices to keep.</p> <p>Parameters:</p> Name Type Description Default <code>rows_to_keep</code> <code>list[int]</code> <p>List of indices indicating rows to keep.</p> required Source code in <code>itv_asset_tree/utils/duplicate_resolution.py</code> <pre><code>def __init__(self, rows_to_keep):\n    \"\"\"\n    Initializes the strategy with a list of row indices to keep.\n\n    Args:\n        rows_to_keep (list[int]): List of indices indicating rows to keep.\n    \"\"\"\n    self.rows_to_keep = rows_to_keep\n</code></pre>"},{"location":"#itv_asset_tree.utils.logger.log_debug","title":"<code>log_debug(message)</code>","text":"<p>Logs a debug message.</p> Source code in <code>itv_asset_tree/utils/logger.py</code> <pre><code>def log_debug(message: str):\n    \"\"\"Logs a debug message.\"\"\"\n    logger.debug(message)\n</code></pre>"},{"location":"#itv_asset_tree.utils.logger.log_error","title":"<code>log_error(message)</code>","text":"<p>Logs an error message.</p> Source code in <code>itv_asset_tree/utils/logger.py</code> <pre><code>def log_error(message: str):\n    \"\"\"Logs an error message.\"\"\"\n    logger.error(message)\n</code></pre>"},{"location":"#itv_asset_tree.utils.logger.log_info","title":"<code>log_info(message)</code>","text":"<p>Logs an informational message.</p> Source code in <code>itv_asset_tree/utils/logger.py</code> <pre><code>def log_info(message: str):\n    \"\"\"Logs an informational message.\"\"\"\n    logger.info(message)\n</code></pre>"},{"location":"#itv_asset_tree.utils.logger.log_warning","title":"<code>log_warning(message)</code>","text":"<p>Logs a warning message.</p> Source code in <code>itv_asset_tree/utils/logger.py</code> <pre><code>def log_warning(message: str):\n    \"\"\"Logs a warning message.\"\"\"\n    logger.warning(message)\n</code></pre>"},{"location":"#itv_asset_tree.utils.lookup_builder.LookupTableBuilder","title":"<code>LookupTableBuilder</code>","text":"<p>Builds lookup tables from cleaned data.</p> <p>This class is responsible for creating lookup tables from a DataFrame and saving them in a structured CSV format for later use.</p> Source code in <code>itv_asset_tree/utils/lookup_builder.py</code> <pre><code>class LookupTableBuilder:\n    \"\"\"\n    Builds lookup tables from cleaned data.\n\n    This class is responsible for creating lookup tables from a DataFrame and saving\n    them in a structured CSV format for later use.\n    \"\"\"\n\n    def __init__(self, group_column, key_column, value_column):\n        \"\"\"\n        Initializes the LookupTableBuilder with specified columns.\n\n        Args:\n            group_column (str): The column used for grouping data.\n            key_column (str): The column containing keys.\n            value_column (str): The column containing values.\n        \"\"\"\n        self.group_column = group_column\n        self.key_column = key_column\n        self.value_column = value_column\n\n    # Add a new method to the class to build lookup tables as a dictionary\n    def build(self, data):\n        \"\"\"\n        Builds lookup tables as a dictionary from a given DataFrame.\n\n        Args:\n            data (DataFrame): The DataFrame containing the data.\n\n        Returns:\n            dict: A dictionary where keys are group names and values are lookup tables.\n        \"\"\"\n        lookup_tables = {}\n        for group_name, group in data.groupby(self.group_column):\n            table = [[str(row[self.key_column]), str(row[self.value_column])] for _, row in group.iterrows()]\n            lookup_tables[group_name] = table\n        return lookup_tables\n\n    # Add a new static method to the class to save the lookup table data to a CSV file\n    @staticmethod\n    def save_lookup_to_csv(lookup_data, parent_paths, output_file):\n        \"\"\"\n        Saves lookup table data to a CSV file in the required format.\n\n        Args:\n            lookup_data (dict): Lookup table dictionary where keys are group names.\n            parent_paths (dict): Dictionary mapping group names to Parent Paths.\n            output_file (str): Path to save the output CSV file.\n        \"\"\"\n        fields = [\"Name\", \"Formula\", \"Formula Parameters\", \"Parent Path\"]\n        rows = []\n\n        for group_name, table in lookup_data.items():\n            # Correct JSON dump, without additional escaping\n            formatted_formula = json.dumps(table, ensure_ascii=False)\n\n            # Print the formula *before* writing it\n            log_debug(f\"\ud83d\udea8 DEBUG: About to save formula for '{group_name}': {formatted_formula}\")\n\n            rows.append({\n                \"Name\": group_name.replace(\" \", \"_\") + \"_LookupString\",\n                \"Formula\": f'\"{formatted_formula}\"',\n                \"Formula Parameters\": \"{}\",\n                \"Parent Path\": parent_paths.get(group_name, \"Root Asset\"),\n            })\n\n        # Write CSV\n        with open(output_file, mode=\"w\", newline=\"\", encoding=\"utf-8\") as file:\n            writer = csv.DictWriter(file, fieldnames=fields, quoting=csv.QUOTE_MINIMAL)\n            writer.writeheader()\n            writer.writerows(rows)\n\n        log_info(f\"\u2705 Lookup CSV file '{output_file}' created successfully.\")\n</code></pre>"},{"location":"#itv_asset_tree.utils.lookup_builder.LookupTableBuilder.__init__","title":"<code>__init__(group_column, key_column, value_column)</code>","text":"<p>Initializes the LookupTableBuilder with specified columns.</p> <p>Parameters:</p> Name Type Description Default <code>group_column</code> <code>str</code> <p>The column used for grouping data.</p> required <code>key_column</code> <code>str</code> <p>The column containing keys.</p> required <code>value_column</code> <code>str</code> <p>The column containing values.</p> required Source code in <code>itv_asset_tree/utils/lookup_builder.py</code> <pre><code>def __init__(self, group_column, key_column, value_column):\n    \"\"\"\n    Initializes the LookupTableBuilder with specified columns.\n\n    Args:\n        group_column (str): The column used for grouping data.\n        key_column (str): The column containing keys.\n        value_column (str): The column containing values.\n    \"\"\"\n    self.group_column = group_column\n    self.key_column = key_column\n    self.value_column = value_column\n</code></pre>"},{"location":"#itv_asset_tree.utils.lookup_builder.LookupTableBuilder.build","title":"<code>build(data)</code>","text":"<p>Builds lookup tables as a dictionary from a given DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>The DataFrame containing the data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary where keys are group names and values are lookup tables.</p> Source code in <code>itv_asset_tree/utils/lookup_builder.py</code> <pre><code>def build(self, data):\n    \"\"\"\n    Builds lookup tables as a dictionary from a given DataFrame.\n\n    Args:\n        data (DataFrame): The DataFrame containing the data.\n\n    Returns:\n        dict: A dictionary where keys are group names and values are lookup tables.\n    \"\"\"\n    lookup_tables = {}\n    for group_name, group in data.groupby(self.group_column):\n        table = [[str(row[self.key_column]), str(row[self.value_column])] for _, row in group.iterrows()]\n        lookup_tables[group_name] = table\n    return lookup_tables\n</code></pre>"},{"location":"#itv_asset_tree.utils.lookup_builder.LookupTableBuilder.save_lookup_to_csv","title":"<code>save_lookup_to_csv(lookup_data, parent_paths, output_file)</code>  <code>staticmethod</code>","text":"<p>Saves lookup table data to a CSV file in the required format.</p> <p>Parameters:</p> Name Type Description Default <code>lookup_data</code> <code>dict</code> <p>Lookup table dictionary where keys are group names.</p> required <code>parent_paths</code> <code>dict</code> <p>Dictionary mapping group names to Parent Paths.</p> required <code>output_file</code> <code>str</code> <p>Path to save the output CSV file.</p> required Source code in <code>itv_asset_tree/utils/lookup_builder.py</code> <pre><code>@staticmethod\ndef save_lookup_to_csv(lookup_data, parent_paths, output_file):\n    \"\"\"\n    Saves lookup table data to a CSV file in the required format.\n\n    Args:\n        lookup_data (dict): Lookup table dictionary where keys are group names.\n        parent_paths (dict): Dictionary mapping group names to Parent Paths.\n        output_file (str): Path to save the output CSV file.\n    \"\"\"\n    fields = [\"Name\", \"Formula\", \"Formula Parameters\", \"Parent Path\"]\n    rows = []\n\n    for group_name, table in lookup_data.items():\n        # Correct JSON dump, without additional escaping\n        formatted_formula = json.dumps(table, ensure_ascii=False)\n\n        # Print the formula *before* writing it\n        log_debug(f\"\ud83d\udea8 DEBUG: About to save formula for '{group_name}': {formatted_formula}\")\n\n        rows.append({\n            \"Name\": group_name.replace(\" \", \"_\") + \"_LookupString\",\n            \"Formula\": f'\"{formatted_formula}\"',\n            \"Formula Parameters\": \"{}\",\n            \"Parent Path\": parent_paths.get(group_name, \"Root Asset\"),\n        })\n\n    # Write CSV\n    with open(output_file, mode=\"w\", newline=\"\", encoding=\"utf-8\") as file:\n        writer = csv.DictWriter(file, fieldnames=fields, quoting=csv.QUOTE_MINIMAL)\n        writer.writeheader()\n        writer.writerows(rows)\n\n    log_info(f\"\u2705 Lookup CSV file '{output_file}' created successfully.\")\n</code></pre>"},{"location":"#itv_asset_tree.utils.metadata_handler.load_metadata","title":"<code>load_metadata(file_path)</code>","text":"<p>Loads metadata from a file using pickle deserialization.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the metadata file to be loaded.</p> required <p>Returns:</p> Name Type Description <code>any</code> <p>The deserialized metadata object.</p> Source code in <code>itv_asset_tree/utils/metadata_handler.py</code> <pre><code>def load_metadata(file_path):\n    \"\"\"\n    Loads metadata from a file using pickle deserialization.\n\n    Args:\n        file_path (str): The path to the metadata file to be loaded.\n\n    Returns:\n        any: The deserialized metadata object.\n    \"\"\"\n    with open(file_path, \"rb\") as f:\n        metadata = pickle.load(f)\n    log_info(f\"\u2705 Metadata loaded from {file_path}\")\n    return metadata\n</code></pre>"},{"location":"#itv_asset_tree.utils.metadata_handler.save_metadata","title":"<code>save_metadata(metadata, file_path)</code>","text":"<p>Saves metadata to a file using pickle serialization.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>any</code> <p>The metadata object to be saved.</p> required <code>file_path</code> <code>str</code> <p>The path where the metadata file will be stored.</p> required Source code in <code>itv_asset_tree/utils/metadata_handler.py</code> <pre><code>def save_metadata(metadata, file_path):\n    \"\"\"\n    Saves metadata to a file using pickle serialization.\n\n    Args:\n        metadata (any): The metadata object to be saved.\n        file_path (str): The path where the metadata file will be stored.\n    \"\"\"\n    with open(file_path, \"wb\") as f:\n        pickle.dump(metadata, f)\n    log_info(f\"\u2705 Metadata saved to {file_path}\")\n</code></pre>"},{"location":"#itv_asset_tree.utils.template_builder.build_template","title":"<code>build_template(request, template_entry)</code>","text":"<p>Build an HVAC-style asset tree using Region &gt;&gt; Facility &gt;&gt; Section &gt;&gt; Component hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>BuildRequest</code> <p>Fully validated build request.</p> required <code>template_entry</code> <p>Entry point class from the asset model template.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Build results pushed to Seeq.</p> Source code in <code>itv_asset_tree/utils/template_builder.py</code> <pre><code>def build_template(request: BuildRequest, template_entry) -&gt; pd.DataFrame:\n    \"\"\"\n    Build an HVAC-style asset tree using Region &gt;&gt; Facility &gt;&gt; Section &gt;&gt; Component hierarchy.\n\n    Args:\n        request (BuildRequest): Fully validated build request.\n        template_entry: Entry point class from the asset model template.\n\n    Returns:\n        pd.DataFrame: Build results pushed to Seeq.\n    \"\"\"\n    log_info(f\"\ud83d\udd0d Received request: {request.dict()}\")\n    request_type = request.type or \"StoredSignal\"\n    log_info(f\"\ud83e\uddfe Raw request.section_name_regex: {repr(request.section_name_regex)}\")\n    try:\n        # Step 1: Signal search\n        if request.path:\n            log_info(f\"\ud83d\udce1 Searching signals via asset tree path: {request.path}\")\n            search_results = SeeqSpyAdapter.search_in_tree(\n                search_query=request.search_query,\n                tree_path=request.path\n            )\n        else:\n            log_info(f\"\ud83d\udce1 Searching signals via raw datasource: {request.datasource_name}\")\n            search_results = SeeqSpyAdapter.search(\n                request.search_query, request_type, request.datasource_name\n            )\n\n        if search_results.empty:\n            return {\n                \"status\": 400,\n                \"statusMessage\": \"\ud83d\udea8 No matching signals found in Seeq!\"\n            }\n\n        log_info(f\"\ud83e\uddee Total signals found: {len(search_results)}\")\n\n        # Step 2: Core hierarchy\n        region_name = request.region_name or request.build_path.split(\"&gt;&gt;\")[0].strip()\n        facility_name = request.facility_name or \"Facility #1\"\n        search_results[\"Region\"] = region_name\n        search_results[\"Facility\"] = facility_name\n\n        if not region_name:\n            return {\n                \"status\": 400,\n                \"statusMessage\": \"\ud83d\udea8 Region name is missing!\"\n            }\n\n        # Step 3: Section extraction with human-friendly regex handling\n        raw_section_regex = request.section_name_regex\n        log_info(f\"\ud83d\udce8 Raw section_name_regex input: {repr(raw_section_regex)}\")\n\n        # Normalize and validate regex string\n        try:\n            # If user gave double-backslashes like \"Area (\\\\w).*\", unescape it\n            if raw_section_regex and \"\\\\\\\\\" in raw_section_regex:\n                section_regex = raw_section_regex.encode('utf-8').decode('unicode_escape')\n                log_info(f\"\ud83e\uddfc Unescaped regex to: {section_regex}\")\n            else:\n                section_regex = raw_section_regex or r\"Area (\\w).*\"\n\n            # Try compiling it to confirm it's valid\n            re.compile(section_regex)\n            log_info(f\"\ud83d\udcd0 Using final section_name_regex: {section_regex}\")\n\n        except Exception as e:\n            section_regex = r\"Area (\\w).*\"\n            log_warning(f\"\u26a0\ufe0f Invalid regex supplied: {raw_section_regex} \u2192 Falling back to: {section_regex}\")\n\n        # Apply to data\n        search_results[\"Section\"] = search_results[\"Name\"].str.extract(section_regex, expand=False)\n        search_results[\"Section\"] = \"Section \" + search_results[\"Section\"].fillna(\"General\")\n\n        log_info(\"\ud83d\udccc Unique Sections Found:\")\n        log_info(search_results[\"Section\"].value_counts().to_string())\n\n        # Step 4: Extract asset name (after underscore)\n        search_results[\"Asset\"] = search_results[\"Name\"].apply(\n            lambda x: x.split(\"_\", 1)[1] if \"_\" in x else x\n        )\n\n        # Step 5: ID and Type enforcement\n        if \"ID\" not in search_results.columns or search_results[\"ID\"].isnull().all():\n            return {\n                \"status\": 400,\n                \"statusMessage\": \"\ud83d\udea8 Missing 'ID' column for Seeq linkage.\"\n            }\n\n        search_results[\"Type\"] = request_type\n        search_results[\"Build Path\"] = None\n        search_results[\"Build Asset\"] = region_name  # Placeholder\n\n        # Step 6: Component extraction\n        try:\n            components_list = get_config_value(\"templates.components\", [])\n        except Exception as e:\n            log_warning(f\"\u26a0\ufe0f Could not load components from config: {e}\")\n            components_list = []\n\n        if components_list:\n            pattern = \"|\".join([re.escape(c) for c in components_list])\n            search_results[\"Component\"] = search_results[\"Name\"].str.extract(rf\"({pattern})\", flags=re.IGNORECASE)[0]\n            log_info(f\"\u2705 Extracted Components using regex: {pattern}\")\n            log_info(search_results[\"Component\"].value_counts().to_string())\n        else:\n            log_warning(\"\u26a0\ufe0f No components found in config.yaml \u2192 using fallback 'Misc'\")\n            search_results[\"Component\"] = \"Misc\"\n\n        log_info(f\"\u2705 Resolved template entry: {template_entry.__name__} (from template: {request.template_name})\")\n\n        # Step 7: Build + Push\n        build_df = SeeqSpyAdapter.build_and_push(\n            model_class=template_entry,\n            metadata_df=search_results,\n            workbook_name=request.workbook_name\n        )\n\n        log_info(\"\ud83e\uddfc Preview of build DataFrame:\")\n        log_info(build_df)\n\n        return build_df\n\n    except Exception as e:\n        log_error(f\"\u274c Failed HVAC-style build: {e}\\n{traceback.format_exc()}\")\n        return {\n            \"status\": 500,\n            \"statusMessage\": f\"\u274c HVAC-style build failed: {str(e)}\"\n        }\n</code></pre>"}]}